import{X as pr,Y as Yo,Z as Qo,$ as Is,c as je,a0 as ei,B as O,d as ti,a1 as Bs,a2 as Rs,a3 as Ts,a4 as Ls,a5 as zr,a6 as gr,C as un,k as V,a7 as jr,y as yr,J as mr,a8 as wr,_ as Lt,a9 as Vt,aa as Rn,ab as ni}from"./index-6f172409.js";import{n as ri}from"./nacl-fast-5abebb94.js";var ln={},si={get exports(){return ln},set exports(r){ln=r}},$r;function oi(){return $r||($r=1,function(r){function e(n,s,o,i,a,c,u){try{var f=n[c](u),l=f.value}catch(w){o(w);return}f.done?s(l):Promise.resolve(l).then(i,a)}function t(n){return function(){var s=this,o=arguments;return new Promise(function(i,a){var c=n.apply(s,o);function u(l){e(c,i,a,u,f,"next",l)}function f(l){e(c,i,a,u,f,"throw",l)}u(void 0)})}}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(si)),ln}var fn={},ii={get exports(){return fn},set exports(r){fn=r}},Wr;function ai(){return Wr||(Wr=1,function(r){var e=pr().default;function t(){r.exports=t=function(){return n},r.exports.__esModule=!0,r.exports.default=r.exports;var n={},s=Object.prototype,o=s.hasOwnProperty,i=Object.defineProperty||function(R,A,I){R[A]=I.value},a=typeof Symbol=="function"?Symbol:{},c=a.iterator||"@@iterator",u=a.asyncIterator||"@@asyncIterator",f=a.toStringTag||"@@toStringTag";function l(R,A,I){return Object.defineProperty(R,A,{value:I,enumerable:!0,configurable:!0,writable:!0}),R[A]}try{l({},"")}catch{l=function(I,D,$){return I[D]=$}}function w(R,A,I,D){var $=A&&A.prototype instanceof p?A:p,z=Object.create($.prototype),ce=new Ee(D||[]);return i(z,"_invoke",{value:F(R,I,ce)}),z}function d(R,A,I){try{return{type:"normal",arg:R.call(A,I)}}catch(D){return{type:"throw",arg:D}}}n.wrap=w;var h={};function p(){}function y(){}function x(){}var S={};l(S,c,function(){return this});var b=Object.getPrototypeOf,C=b&&b(b(Fe([])));C&&C!==s&&o.call(C,c)&&(S=C);var k=x.prototype=p.prototype=Object.create(S);function M(R){["next","throw","return"].forEach(function(A){l(R,A,function(I){return this._invoke(A,I)})})}function P(R,A){function I($,z,ce,ve){var _e=d(R[$],R,z);if(_e.type!=="throw"){var ft=_e.arg,Xe=ft.value;return Xe&&e(Xe)=="object"&&o.call(Xe,"__await")?A.resolve(Xe.__await).then(function(dt){I("next",dt,ce,ve)},function(dt){I("throw",dt,ce,ve)}):A.resolve(Xe).then(function(dt){ft.value=dt,ce(ft)},function(dt){return I("throw",dt,ce,ve)})}ve(_e.arg)}var D;i(this,"_invoke",{value:function(z,ce){function ve(){return new A(function(_e,ft){I(z,ce,_e,ft)})}return D=D?D.then(ve,ve):ve()}})}function F(R,A,I){var D="suspendedStart";return function($,z){if(D==="executing")throw new Error("Generator is already running");if(D==="completed"){if($==="throw")throw z;return St()}for(I.method=$,I.arg=z;;){var ce=I.delegate;if(ce){var ve=te(ce,I);if(ve){if(ve===h)continue;return ve}}if(I.method==="next")I.sent=I._sent=I.arg;else if(I.method==="throw"){if(D==="suspendedStart")throw D="completed",I.arg;I.dispatchException(I.arg)}else I.method==="return"&&I.abrupt("return",I.arg);D="executing";var _e=d(R,A,I);if(_e.type==="normal"){if(D=I.done?"completed":"suspendedYield",_e.arg===h)continue;return{value:_e.arg,done:I.done}}_e.type==="throw"&&(D="completed",I.method="throw",I.arg=_e.arg)}}}function te(R,A){var I=A.method,D=R.iterator[I];if(D===void 0)return A.delegate=null,I==="throw"&&R.iterator.return&&(A.method="return",A.arg=void 0,te(R,A),A.method==="throw")||I!=="return"&&(A.method="throw",A.arg=new TypeError("The iterator does not provide a '"+I+"' method")),h;var $=d(D,R.iterator,A.arg);if($.type==="throw")return A.method="throw",A.arg=$.arg,A.delegate=null,h;var z=$.arg;return z?z.done?(A[R.resultName]=z.value,A.next=R.nextLoc,A.method!=="return"&&(A.method="next",A.arg=void 0),A.delegate=null,h):z:(A.method="throw",A.arg=new TypeError("iterator result is not an object"),A.delegate=null,h)}function Se(R){var A={tryLoc:R[0]};1 in R&&(A.catchLoc=R[1]),2 in R&&(A.finallyLoc=R[2],A.afterLoc=R[3]),this.tryEntries.push(A)}function Pe(R){var A=R.completion||{};A.type="normal",delete A.arg,R.completion=A}function Ee(R){this.tryEntries=[{tryLoc:"root"}],R.forEach(Se,this),this.reset(!0)}function Fe(R){if(R){var A=R[c];if(A)return A.call(R);if(typeof R.next=="function")return R;if(!isNaN(R.length)){var I=-1,D=function $(){for(;++I<R.length;)if(o.call(R,I))return $.value=R[I],$.done=!1,$;return $.value=void 0,$.done=!0,$};return D.next=D}}return{next:St}}function St(){return{value:void 0,done:!0}}return y.prototype=x,i(k,"constructor",{value:x,configurable:!0}),i(x,"constructor",{value:y,configurable:!0}),y.displayName=l(x,f,"GeneratorFunction"),n.isGeneratorFunction=function(R){var A=typeof R=="function"&&R.constructor;return!!A&&(A===y||(A.displayName||A.name)==="GeneratorFunction")},n.mark=function(R){return Object.setPrototypeOf?Object.setPrototypeOf(R,x):(R.__proto__=x,l(R,f,"GeneratorFunction")),R.prototype=Object.create(k),R},n.awrap=function(R){return{__await:R}},M(P.prototype),l(P.prototype,u,function(){return this}),n.AsyncIterator=P,n.async=function(R,A,I,D,$){$===void 0&&($=Promise);var z=new P(w(R,A,I,D),$);return n.isGeneratorFunction(A)?z:z.next().then(function(ce){return ce.done?ce.value:z.next()})},M(k),l(k,f,"Generator"),l(k,c,function(){return this}),l(k,"toString",function(){return"[object Generator]"}),n.keys=function(R){var A=Object(R),I=[];for(var D in A)I.push(D);return I.reverse(),function $(){for(;I.length;){var z=I.pop();if(z in A)return $.value=z,$.done=!1,$}return $.done=!0,$}},n.values=Fe,Ee.prototype={constructor:Ee,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(Pe),!A)for(var I in this)I.charAt(0)==="t"&&o.call(this,I)&&!isNaN(+I.slice(1))&&(this[I]=void 0)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if(A.type==="throw")throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var I=this;function D(ft,Xe){return ce.type="throw",ce.arg=A,I.next=ft,Xe&&(I.method="next",I.arg=void 0),!!Xe}for(var $=this.tryEntries.length-1;$>=0;--$){var z=this.tryEntries[$],ce=z.completion;if(z.tryLoc==="root")return D("end");if(z.tryLoc<=this.prev){var ve=o.call(z,"catchLoc"),_e=o.call(z,"finallyLoc");if(ve&&_e){if(this.prev<z.catchLoc)return D(z.catchLoc,!0);if(this.prev<z.finallyLoc)return D(z.finallyLoc)}else if(ve){if(this.prev<z.catchLoc)return D(z.catchLoc,!0)}else{if(!_e)throw new Error("try statement without catch or finally");if(this.prev<z.finallyLoc)return D(z.finallyLoc)}}}},abrupt:function(A,I){for(var D=this.tryEntries.length-1;D>=0;--D){var $=this.tryEntries[D];if($.tryLoc<=this.prev&&o.call($,"finallyLoc")&&this.prev<$.finallyLoc){var z=$;break}}z&&(A==="break"||A==="continue")&&z.tryLoc<=I&&I<=z.finallyLoc&&(z=null);var ce=z?z.completion:{};return ce.type=A,ce.arg=I,z?(this.method="next",this.next=z.finallyLoc,h):this.complete(ce)},complete:function(A,I){if(A.type==="throw")throw A.arg;return A.type==="break"||A.type==="continue"?this.next=A.arg:A.type==="return"?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):A.type==="normal"&&I&&(this.next=I),h},finish:function(A){for(var I=this.tryEntries.length-1;I>=0;--I){var D=this.tryEntries[I];if(D.finallyLoc===A)return this.complete(D.completion,D.afterLoc),Pe(D),h}},catch:function(A){for(var I=this.tryEntries.length-1;I>=0;--I){var D=this.tryEntries[I];if(D.tryLoc===A){var $=D.completion;if($.type==="throw"){var z=$.arg;Pe(D)}return z}}throw new Error("illegal catch attempt")},delegateYield:function(A,I,D){return this.delegate={iterator:Fe(A),resultName:I,nextLoc:D},this.method==="next"&&(this.arg=void 0),h}},n}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(ii)),fn}var Dn,Gr;function ci(){if(Gr)return Dn;Gr=1;var r=ai()();Dn=r;try{regeneratorRuntime=r}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}return Dn}var nn=Yo.Buffer;function ui(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function f(d){if((Array.isArray(d)||d instanceof Uint8Array)&&(d=nn.from(d)),!nn.isBuffer(d))throw new TypeError("Expected Buffer");if(d.length===0)return"";for(var h=0,p=0,y=0,x=d.length;y!==x&&d[y]===0;)y++,h++;for(var S=(x-y)*u+1>>>0,b=new Uint8Array(S);y!==x;){for(var C=d[y],k=0,M=S-1;(C!==0||k<p)&&M!==-1;M--,k++)C+=256*b[M]>>>0,b[M]=C%i>>>0,C=C/i>>>0;if(C!==0)throw new Error("Non-zero carry");p=k,y++}for(var P=S-p;P!==S&&b[P]===0;)P++;for(var F=a.repeat(h);P<S;++P)F+=r.charAt(b[P]);return F}function l(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return nn.alloc(0);for(var h=0,p=0,y=0;d[h]===a;)p++,h++;for(var x=(d.length-h)*c+1>>>0,S=new Uint8Array(x);d[h];){var b=e[d.charCodeAt(h)];if(b===255)return;for(var C=0,k=x-1;(b!==0||C<y)&&k!==-1;k--,C++)b+=i*S[k]>>>0,S[k]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=C,h++}for(var M=x-y;M!==x&&S[M]===0;)M++;var P=nn.allocUnsafe(p+(x-M));P.fill(0,0,p);for(var F=p;M!==x;)P[F++]=S[M++];return P}function w(d){var h=l(d);if(h)return h;throw new Error("Non-base"+i+" character")}return{encode:f,decodeUnsafe:l,decode:w}}var li=ui,fi=li,di="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",ee=fi(di);function sr(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function hi(r){if(typeof r!="boolean")throw new Error(`Expected boolean, not ${r}`)}function Ps(r,...e){if(!(r instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(r.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${r.length}`)}function pi(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");sr(r.outputLen),sr(r.blockLen)}function gi(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function yi(r,e){Ps(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const Te={number:sr,bool:hi,bytes:Ps,hash:pi,exists:gi,output:yi};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mi=r=>new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4)),zn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),qe=(r,e)=>r<<32-e|r>>>e,wi=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!wi)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function bi(r){if(typeof r!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof r}`);return new TextEncoder().encode(r)}function Jt(r){if(typeof r=="string"&&(r=bi(r)),!(r instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof r})`);return r}class br{clone(){return this._cloneInto()}}function mt(r){const e=n=>r().update(Jt(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function vi(r){const e=(n,s)=>r(s).update(Jt(n)).digest(),t=r({});return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}function xi(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}class Cs extends br{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=zn(this.buffer)}update(e){Te.exists(this);const{view:t,buffer:n,blockLen:s}=this;e=Jt(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=zn(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Te.exists(this),Te.output(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let l=i;l<s;l++)t[l]=0;xi(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=zn(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,f=this.get();if(u>f.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)a.setUint32(4*l,f[l],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}}const rn=BigInt(2**32-1),or=BigInt(32);function Os(r,e=!1){return e?{h:Number(r&rn),l:Number(r>>or&rn)}:{h:Number(r>>or&rn)|0,l:Number(r&rn)|0}}function Si(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=Os(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const _i=(r,e)=>BigInt(r>>>0)<<or|BigInt(e>>>0),ki=(r,e,t)=>r>>>t,Ai=(r,e,t)=>r<<32-t|e>>>t,Ei=(r,e,t)=>r>>>t|e<<32-t,Ii=(r,e,t)=>r<<32-t|e>>>t,Bi=(r,e,t)=>r<<64-t|e>>>t-32,Ri=(r,e,t)=>r>>>t-32|e<<64-t,Ti=(r,e)=>e,Li=(r,e)=>r,Pi=(r,e,t)=>r<<t|e>>>32-t,Ci=(r,e,t)=>e<<t|r>>>32-t,Oi=(r,e,t)=>e<<t-32|r>>>64-t,Ui=(r,e,t)=>r<<t-32|e>>>64-t;function Ni(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Mi=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Fi=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,qi=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Hi=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Ki=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Di=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,j={fromBig:Os,split:Si,toBig:_i,shrSH:ki,shrSL:Ai,rotrSH:Ei,rotrSL:Ii,rotrBH:Bi,rotrBL:Ri,rotr32H:Ti,rotr32L:Li,rotlSH:Pi,rotlSL:Ci,rotlBH:Oi,rotlBL:Ui,add:Ni,add3L:Mi,add3H:Fi,add4L:qi,add4H:Hi,add5H:Di,add5L:Ki},[zi,ji]=j.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ye=new Uint32Array(80),Qe=new Uint32Array(80);class Tn extends Cs{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:f,Fh:l,Fl:w,Gh:d,Gl:h,Hh:p,Hl:y}=this;return[e,t,n,s,o,i,a,c,u,f,l,w,d,h,p,y]}set(e,t,n,s,o,i,a,c,u,f,l,w,d,h,p,y){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=f|0,this.Fh=l|0,this.Fl=w|0,this.Gh=d|0,this.Gl=h|0,this.Hh=p|0,this.Hl=y|0}process(e,t){for(let b=0;b<16;b++,t+=4)Ye[b]=e.getUint32(t),Qe[b]=e.getUint32(t+=4);for(let b=16;b<80;b++){const C=Ye[b-15]|0,k=Qe[b-15]|0,M=j.rotrSH(C,k,1)^j.rotrSH(C,k,8)^j.shrSH(C,k,7),P=j.rotrSL(C,k,1)^j.rotrSL(C,k,8)^j.shrSL(C,k,7),F=Ye[b-2]|0,te=Qe[b-2]|0,Se=j.rotrSH(F,te,19)^j.rotrBH(F,te,61)^j.shrSH(F,te,6),Pe=j.rotrSL(F,te,19)^j.rotrBL(F,te,61)^j.shrSL(F,te,6),Ee=j.add4L(P,Pe,Qe[b-7],Qe[b-16]),Fe=j.add4H(Ee,M,Se,Ye[b-7],Ye[b-16]);Ye[b]=Fe|0,Qe[b]=Ee|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:f,Eh:l,El:w,Fh:d,Fl:h,Gh:p,Gl:y,Hh:x,Hl:S}=this;for(let b=0;b<80;b++){const C=j.rotrSH(l,w,14)^j.rotrSH(l,w,18)^j.rotrBH(l,w,41),k=j.rotrSL(l,w,14)^j.rotrSL(l,w,18)^j.rotrBL(l,w,41),M=l&d^~l&p,P=w&h^~w&y,F=j.add5L(S,k,P,ji[b],Qe[b]),te=j.add5H(F,x,C,M,zi[b],Ye[b]),Se=F|0,Pe=j.rotrSH(n,s,28)^j.rotrBH(n,s,34)^j.rotrBH(n,s,39),Ee=j.rotrSL(n,s,28)^j.rotrBL(n,s,34)^j.rotrBL(n,s,39),Fe=n&o^n&a^o&a,St=s&i^s&c^i&c;x=p|0,S=y|0,p=d|0,y=h|0,d=l|0,h=w|0,{h:l,l:w}=j.add(u|0,f|0,te|0,Se|0),u=a|0,f=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const R=j.add3L(Se,Ee,St);n=j.add3H(R,te,Pe,Fe),s=R|0}({h:n,l:s}=j.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=j.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=j.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:f}=j.add(this.Dh|0,this.Dl|0,u|0,f|0),{h:l,l:w}=j.add(this.Eh|0,this.El|0,l|0,w|0),{h:d,l:h}=j.add(this.Fh|0,this.Fl|0,d|0,h|0),{h:p,l:y}=j.add(this.Gh|0,this.Gl|0,p|0,y|0),{h:x,l:S}=j.add(this.Hh|0,this.Hl|0,x|0,S|0),this.set(n,s,o,i,a,c,u,f,l,w,d,h,p,y,x,S)}roundClean(){Ye.fill(0),Qe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $i extends Tn{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class Wi extends Tn{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class Gi extends Tn{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Vi=mt(()=>new Tn);mt(()=>new $i);mt(()=>new Wi);mt(()=>new Gi);/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const pe=BigInt(0),Z=BigInt(1),st=BigInt(2),Ji=BigInt(8),Vr=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),re=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:Vr,n:Vr,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),Us=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),qt=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const Zi=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),Xi=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),Yi=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Qi=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class J{constructor(e,t,n,s){this.x=e,this.y=t,this.z=n,this.t=s}static fromAffine(e){if(!(e instanceof ae))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return e.equals(ae.ZERO)?J.ZERO:new J(e.x,e.y,Z,v(e.x*e.y))}static toAffineBatch(e){const t=na(e.map(n=>n.z));return e.map((n,s)=>n.toAffine(t[s]))}static normalizeZ(e){return this.toAffineBatch(e).map(this.fromAffine)}equals(e){Zr(e);const{x:t,y:n,z:s}=this,{x:o,y:i,z:a}=e,c=v(t*a),u=v(o*s),f=v(n*a),l=v(i*s);return c===u&&f===l}negate(){return new J(v(-this.x),this.y,this.z,v(-this.t))}double(){const{x:e,y:t,z:n}=this,{a:s}=re,o=v(e*e),i=v(t*t),a=v(st*v(n*n)),c=v(s*o),u=e+t,f=v(v(u*u)-o-i),l=c+i,w=l-a,d=c-i,h=v(f*w),p=v(l*d),y=v(f*d),x=v(w*l);return new J(h,p,x,y)}add(e){Zr(e);const{x:t,y:n,z:s,t:o}=this,{x:i,y:a,z:c,t:u}=e,f=v((n-t)*(a+i)),l=v((n+t)*(a-i)),w=v(l-f);if(w===pe)return this.double();const d=v(s*st*u),h=v(o*st*c),p=h+d,y=l+f,x=h-d,S=v(p*w),b=v(y*x),C=v(p*x),k=v(w*y);return new J(S,b,k,C)}subtract(e){return this.add(e.negate())}precomputeWindow(e){const t=1+256/e,n=[];let s=this,o=s;for(let i=0;i<t;i++){o=s,n.push(o);for(let a=1;a<2**(e-1);a++)o=o.add(s),n.push(o);s=o.double()}return n}wNAF(e,t){!t&&this.equals(J.BASE)&&(t=ae.BASE);const n=t&&t._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let s=t&&ir.get(t);s||(s=this.precomputeWindow(n),t&&n!==1&&(s=J.normalizeZ(s),ir.set(t,s)));let o=J.ZERO,i=J.BASE;const a=1+256/n,c=2**(n-1),u=BigInt(2**n-1),f=2**n,l=BigInt(n);for(let w=0;w<a;w++){const d=w*c;let h=Number(e&u);e>>=l,h>c&&(h-=f,e+=Z);const p=d,y=d+Math.abs(h)-1,x=w%2!==0,S=h<0;h===0?i=i.add(Jr(x,s[p])):o=o.add(Jr(S,s[y]))}return J.normalizeZ([o,i])[0]}multiply(e,t){return this.wNAF(hn(e,re.l),t)}multiplyUnsafe(e){let t=hn(e,re.l,!1);const n=J.BASE,s=J.ZERO;if(t===pe)return s;if(this.equals(s)||t===Z)return this;if(this.equals(n))return this.wNAF(t);let o=s,i=this;for(;t>pe;)t&Z&&(o=o.add(i)),i=i.double(),t>>=Z;return o}isSmallOrder(){return this.multiplyUnsafe(re.h).equals(J.ZERO)}isTorsionFree(){let e=this.multiplyUnsafe(re.l/st).double();return re.l%st&&(e=e.add(this)),e.equals(J.ZERO)}toAffine(e){const{x:t,y:n,z:s}=this,o=this.equals(J.ZERO);e==null&&(e=o?Ji:Ln(s));const i=v(t*e),a=v(n*e),c=v(s*e);if(o)return ae.ZERO;if(c!==Z)throw new Error("invZ was invalid");return new ae(i,a)}fromRistrettoBytes(){$n()}toRistrettoBytes(){$n()}fromRistrettoHash(){$n()}}J.BASE=new J(re.Gx,re.Gy,Z,v(re.Gx*re.Gy));J.ZERO=new J(pe,Z,Z,pe);function Jr(r,e){const t=e.negate();return r?t:e}function Zr(r){if(!(r instanceof J))throw new TypeError("ExtendedPoint expected")}function jn(r){if(!(r instanceof Oe))throw new TypeError("RistrettoPoint expected")}function $n(){throw new Error("Legacy method: switch to RistrettoPoint")}class Oe{constructor(e){this.ep=e}static calcElligatorRistrettoMap(e){const{d:t}=re,n=v(qt*e*e),s=v((n+Z)*Yi);let o=BigInt(-1);const i=v((o-t*n)*v(n+t));let{isValid:a,value:c}=xr(s,i),u=v(c*e);rt(u)||(u=v(-u)),a||(c=u),a||(o=n);const f=v(o*(n-Z)*Qi-i),l=c*c,w=v((c+c)*i),d=v(f*Zi),h=v(Z-l),p=v(Z+l);return new J(v(w*p),v(h*d),v(d*p),v(w*h))}static hashToCurve(e){e=ut(e,64);const t=Wn(e.slice(0,32)),n=this.calcElligatorRistrettoMap(t),s=Wn(e.slice(32,64)),o=this.calcElligatorRistrettoMap(s);return new Oe(n.add(o))}static fromHex(e){e=ut(e,32);const{a:t,d:n}=re,s="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",o=Wn(e);if(!sa(zt(o),e)||rt(o))throw new Error(s);const i=v(o*o),a=v(Z+t*i),c=v(Z-t*i),u=v(a*a),f=v(c*c),l=v(t*n*u-f),{isValid:w,value:d}=Yr(v(l*f)),h=v(d*c),p=v(d*h*l);let y=v((o+o)*h);rt(y)&&(y=v(-y));const x=v(a*p),S=v(y*x);if(!w||rt(S)||x===pe)throw new Error(s);return new Oe(new J(y,x,Z,S))}toRawBytes(){let{x:e,y:t,z:n,t:s}=this.ep;const o=v(v(n+t)*v(n-t)),i=v(e*t),a=v(i*i),{value:c}=Yr(v(o*a)),u=v(c*o),f=v(c*i),l=v(u*f*s);let w;if(rt(s*l)){let h=v(t*qt),p=v(e*qt);e=h,t=p,w=v(u*Xi)}else w=f;rt(e*l)&&(t=v(-t));let d=v((n-t)*w);return rt(d)&&(d=v(-d)),zt(d)}toHex(){return Zt(this.toRawBytes())}toString(){return this.toHex()}equals(e){jn(e);const t=this.ep,n=e.ep,s=v(t.x*n.y)===v(t.y*n.x),o=v(t.y*n.y)===v(t.x*n.x);return s||o}add(e){return jn(e),new Oe(this.ep.add(e.ep))}subtract(e){return jn(e),new Oe(this.ep.subtract(e.ep))}multiply(e){return new Oe(this.ep.multiply(e))}multiplyUnsafe(e){return new Oe(this.ep.multiplyUnsafe(e))}}Oe.BASE=new Oe(J.BASE);Oe.ZERO=new Oe(J.ZERO);const ir=new WeakMap;class ae{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,ir.delete(this)}static fromHex(e,t=!0){const{d:n,P:s}=re;e=ut(e,32);const o=e.slice();o[31]=e[31]&-129;const i=Xt(o);if(t&&i>=s)throw new Error("Expected 0 < hex < P");if(!t&&i>=Us)throw new Error("Expected 0 < hex < 2**256");const a=v(i*i),c=v(a-Z),u=v(n*a+Z);let{isValid:f,value:l}=xr(c,u);if(!f)throw new Error("Point.fromHex: invalid y coordinate");const w=(l&Z)===Z;return(e[31]&128)!==0!==w&&(l=v(-l)),new ae(l,i)}static async fromPrivateKey(e){return(await qs(e)).point}toRawBytes(){const e=zt(this.y);return e[31]|=this.x&Z?128:0,e}toHex(){return Zt(this.toRawBytes())}toX25519(){const{y:e}=this,t=v((Z+e)*Ln(Z-e));return zt(t)}isTorsionFree(){return J.fromAffine(this).isTorsionFree()}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new ae(v(-this.x),this.y)}add(e){return J.fromAffine(this).add(J.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return J.fromAffine(this).multiply(e,this).toAffine()}}ae.BASE=new ae(re.Gx,re.Gy);ae.ZERO=new ae(pe,Z);class Dt{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromHex(e){const t=ut(e,64),n=ae.fromHex(t.slice(0,32),!1),s=Xt(t.slice(32,64));return new Dt(n,s)}assertValidity(){const{r:e,s:t}=this;if(!(e instanceof ae))throw new Error("Expected Point instance");return hn(t,re.l,!1),this}toRawBytes(){const e=new Uint8Array(64);return e.set(this.r.toRawBytes()),e.set(zt(this.s),32),e}toHex(){return Zt(this.toRawBytes())}}function Xr(...r){if(!r.every(n=>n instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(r.length===1)return r[0];const e=r.reduce((n,s)=>n+s.length,0),t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}const ea=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Zt(r){if(!(r instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let t=0;t<r.length;t++)e+=ea[r[t]];return e}function vr(r){if(typeof r!="string")throw new TypeError("hexToBytes: expected string, got "+typeof r);if(r.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(r.length/2);for(let t=0;t<e.length;t++){const n=t*2,s=r.slice(n,n+2),o=Number.parseInt(s,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[t]=o}return e}function Ns(r){const t=r.toString(16).padStart(64,"0");return vr(t)}function zt(r){return Ns(r).reverse()}function rt(r){return(v(r)&Z)===Z}function Xt(r){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+Zt(Uint8Array.from(r).reverse()))}const ta=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function Wn(r){return v(Xt(r)&ta)}function v(r,e=re.P){const t=r%e;return t>=pe?t:e+t}function Ln(r,e=re.P){if(r===pe||e<=pe)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=v(r,e),n=e,s=pe,o=Z;for(;t!==pe;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==Z)throw new Error("invert: does not exist");return v(s,e)}function na(r,e=re.P){const t=new Array(r.length),n=r.reduce((o,i,a)=>i===pe?o:(t[a]=o,v(o*i,e)),Z),s=Ln(n,e);return r.reduceRight((o,i,a)=>i===pe?o:(t[a]=v(o*t[a],e),v(o*i,e)),s),t}function He(r,e){const{P:t}=re;let n=r;for(;e-- >pe;)n*=n,n%=t;return n}function ra(r){const{P:e}=re,t=BigInt(5),n=BigInt(10),s=BigInt(20),o=BigInt(40),i=BigInt(80),c=r*r%e*r%e,u=He(c,st)*c%e,f=He(u,Z)*r%e,l=He(f,t)*f%e,w=He(l,n)*l%e,d=He(w,s)*w%e,h=He(d,o)*d%e,p=He(h,i)*h%e,y=He(p,i)*h%e,x=He(y,n)*l%e;return{pow_p_5_8:He(x,st)*r%e,b2:c}}function xr(r,e){const t=v(e*e*e),n=v(t*t*e),s=ra(r*n).pow_p_5_8;let o=v(r*t*s);const i=v(e*o*o),a=o,c=v(o*qt),u=i===r,f=i===v(-r),l=i===v(-r*qt);return u&&(o=a),(f||l)&&(o=c),rt(o)&&(o=v(-o)),{isValid:u||f,value:o}}function Yr(r){return xr(Z,r)}function dn(r){return v(Xt(r),re.l)}function sa(r,e){if(r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function ut(r,e){const t=r instanceof Uint8Array?Uint8Array.from(r):vr(r);if(typeof e=="number"&&t.length!==e)throw new Error(`Expected ${e} bytes`);return t}function hn(r,e,t=!0){if(!e)throw new TypeError("Specify max value");if(typeof r=="number"&&Number.isSafeInteger(r)&&(r=BigInt(r)),typeof r=="bigint"&&r<e){if(t){if(pe<r)return r}else if(pe<=r)return r}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function oa(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Ms(r){if(r=typeof r=="bigint"||typeof r=="number"?Ns(hn(r,Us)):ut(r),r.length!==32)throw new Error("Expected 32 bytes");return r}function Fs(r){const e=oa(r.slice(0,32)),t=r.slice(32,64),n=dn(e),s=ae.BASE.multiply(n),o=s.toRawBytes();return{head:e,prefix:t,scalar:n,point:s,pointBytes:o}}let Ht;function pn(...r){if(typeof Ht!="function")throw new Error("utils.sha512Sync must be set to use sync methods");return Ht(...r)}async function qs(r){return Fs(await yt.sha512(Ms(r)))}function Sr(r){return Fs(pn(Ms(r)))}function ia(r){return Sr(r).pointBytes}function aa(r,e){r=ut(r);const{prefix:t,scalar:n,pointBytes:s}=Sr(e),o=dn(pn(t,r)),i=ae.BASE.multiply(o),a=dn(pn(i.toRawBytes(),s,r)),c=v(o+a*n,re.l);return new Dt(i,c).toRawBytes()}function ca(r,e,t){e=ut(e),t instanceof ae||(t=ae.fromHex(t,!1));const{r:n,s}=r instanceof Dt?r.assertValidity():Dt.fromHex(r),o=J.BASE.multiplyUnsafe(s);return{r:n,s,SB:o,pub:t,msg:e}}function ua(r,e,t,n){const s=dn(n),o=J.fromAffine(r).multiplyUnsafe(s);return J.fromAffine(e).add(o).subtract(t).multiplyUnsafe(re.h).equals(J.ZERO)}function la(r,e,t){const{r:n,SB:s,msg:o,pub:i}=ca(r,e,t),a=pn(n.toRawBytes(),i.toRawBytes(),o);return ua(i,n,s,a)}const _r={getExtendedPublicKey:Sr,getPublicKey:ia,sign:aa,verify:la};ae.BASE._setWindowSize(8);const et={node:Qo,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},yt={bytesToHex:Zt,hexToBytes:vr,concatBytes:Xr,getExtendedPublicKey:qs,mod:v,invert:Ln,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:r=>{if(r=ut(r),r.length<40||r.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return v(Xt(r),re.l-Z)+Z},randomBytes:(r=32)=>{if(et.web)return et.web.getRandomValues(new Uint8Array(r));if(et.node){const{randomBytes:e}=et.node;return new Uint8Array(e(r).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>yt.randomBytes(32),sha512:async(...r)=>{const e=Xr(...r);if(et.web){const t=await et.web.subtle.digest("SHA-512",e.buffer);return new Uint8Array(t)}else{if(et.node)return Uint8Array.from(et.node.createHash("sha512").update(e).digest());throw new Error("The environment doesn't have sha512 function")}},precompute(r=8,e=ae.BASE){const t=e.equals(ae.BASE)?e:new ae(e.x,e.y);return t._setWindowSize(r),t.multiply(st),t},sha512Sync:void 0};Object.defineProperties(yt,{sha512Sync:{configurable:!1,get(){return Ht},set(r){Ht||(Ht=r)}}});const fa=(r,e,t)=>r&e^~r&t,da=(r,e,t)=>r&e^r&t^e&t,ha=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64);class Hs extends Cs{constructor(){super(64,32,8,!1),this.A=tt[0]|0,this.B=tt[1]|0,this.C=tt[2]|0,this.D=tt[3]|0,this.E=tt[4]|0,this.F=tt[5]|0,this.G=tt[6]|0,this.H=tt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let l=0;l<16;l++,t+=4)nt[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const w=nt[l-15],d=nt[l-2],h=qe(w,7)^qe(w,18)^w>>>3,p=qe(d,17)^qe(d,19)^d>>>10;nt[l]=p+nt[l-7]+h+nt[l-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:f}=this;for(let l=0;l<64;l++){const w=qe(a,6)^qe(a,11)^qe(a,25),d=f+w+fa(a,c,u)+ha[l]+nt[l]|0,p=(qe(n,2)^qe(n,13)^qe(n,22))+da(n,s,o)|0;f=u,u=c,c=a,a=i+d|0,i=o,o=s,s=n,n=d+p|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,f=f+this.H|0,this.set(n,s,o,i,a,c,u,f)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class pa extends Hs{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const ar=mt(()=>new Hs);mt(()=>new pa);var he={};function Ve(r,e,t){return e<=r&&r<=t}function Pn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function ga(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function ya(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var gn=-1;function kr(r){this.tokens=[].slice.call(r)}kr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():gn},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var Bt=-1;function Gn(r,e){if(r)throw TypeError("Decoder error");return e||65533}var yn="utf-8";function mn(r,e){if(!(this instanceof mn))return new mn(r,e);if(r=r!==void 0?String(r).toLowerCase():yn,r!==yn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Pn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}mn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=Pn(t),this._streaming||(this._decoder=new ma({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new kr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Bt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Bt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),ya(o)}};function wn(r,e){if(!(this instanceof wn))return new wn(r,e);if(r=r!==void 0?String(r).toLowerCase():yn,r!==yn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Pn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}wn.prototype={encode:function(e,t){e=e?String(e):"",t=Pn(t),this._streaming||(this._encoder=new wa(this._options)),this._streaming=!!t.stream;for(var n=[],s=new kr(ga(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Bt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Bt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function ma(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===gn&&s!==0)return s=0,Gn(e);if(c===gn)return Bt;if(s===0){if(Ve(c,0,127))return c;if(Ve(c,194,223))s=1,t=c-192;else if(Ve(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(Ve(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return Gn(e);return t=t<<6*s,null}if(!Ve(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),Gn(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function wa(r){r.fatal,this.handler=function(e,t){if(t===gn)return Bt;if(Ve(t,0,127))return t;var n,s;Ve(t,128,2047)?(n=1,s=192):Ve(t,2048,65535)?(n=2,s=224):Ve(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const ba=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:mn,TextEncoder:wn},Symbol.toStringTag,{value:"Module"})),va=Is(ba);var xa=je&&je.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),Sa=je&&je.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),$e=je&&je.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},_a=je&&je.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&xa(e,r,t);return Sa(e,r),e},Ks=je&&je.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(he,"__esModule",{value:!0});var Ds=he.deserializeUnchecked=Vs=he.deserialize=Gs=he.serialize=he.BinaryReader=he.BinaryWriter=he.BorshError=he.baseDecode=he.baseEncode=void 0;const it=Ks(ei),zs=Ks(ee),ka=_a(va),Aa=typeof TextDecoder!="function"?ka.TextDecoder:TextDecoder,Ea=new Aa("utf-8",{fatal:!0});function Ia(r){return typeof r=="string"&&(r=O.from(r,"utf8")),zs.default.encode(O.from(r))}he.baseEncode=Ia;function Ba(r){return O.from(zs.default.decode(r))}he.baseDecode=Ba;const Vn=1024;class xe extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}he.BorshError=xe;class js{constructor(){this.buf=O.alloc(Vn),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=O.concat([this.buf,O.alloc(Vn)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(O.from(new it.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(O.from(new it.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(O.from(new it.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(O.from(new it.default(e).toArray("le",64)))}writeBuffer(e){this.buf=O.concat([O.from(this.buf.subarray(0,this.length)),e,O.alloc(Vn)]),this.length+=e.length}writeString(e){this.maybeResize();const t=O.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(O.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}he.BinaryWriter=js;function We(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new xe("Reached the end of buffer when deserializing")}throw o}}}class Le{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new it.default(e,"le")}readU128(){const e=this.readBuffer(16);return new it.default(e,"le")}readU256(){const e=this.readBuffer(32);return new it.default(e,"le")}readU512(){const e=this.readBuffer(64);return new it.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new xe(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Ea.decode(t)}catch(n){throw new xe(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}$e([We],Le.prototype,"readU8",null);$e([We],Le.prototype,"readU16",null);$e([We],Le.prototype,"readU32",null);$e([We],Le.prototype,"readU64",null);$e([We],Le.prototype,"readU128",null);$e([We],Le.prototype,"readU256",null);$e([We],Le.prototype,"readU512",null);$e([We],Le.prototype,"readString",null);$e([We],Le.prototype,"readFixedArray",null);$e([We],Le.prototype,"readArray",null);he.BinaryReader=Le;function $s(r){return r.charAt(0).toUpperCase()+r.slice(1)}function ht(r,e,t,n,s){try{if(typeof n=="string")s[`write${$s(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new xe(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new xe(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)ht(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{ht(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),ht(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{ht(r,e,i,n.key,s),ht(r,e,o,n.value,s)});break}default:throw new xe(`FieldType ${n} unrecognized`)}else Ws(r,t,s)}catch(o){throw o instanceof xe&&o.addToFieldPath(e),o}}function Ws(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new xe(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{ht(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),ht(r,i,e[i],a,t);break}}}else throw new xe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ra(r,e,t=js){const n=new t;return Ws(r,e,n),n.toArray()}var Gs=he.serialize=Ra;function pt(r,e,t,n){try{if(typeof t=="string")return n[`read${$s(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(pt(r,null,t[0],n));return s}else return n.readArray(()=>pt(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?pt(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=pt(r,e,t.key,n),c=pt(r,e,t.value,n);s.set(a,c)}return s}return Ar(r,t,n)}catch(s){throw s instanceof xe&&s.addToFieldPath(e),s}}function Ar(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new xe(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=pt(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new xe(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=pt(r,o,i,t);return new e({[o]:a})}throw new xe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ta(r,e,t,n=Le){const s=new n(t),o=Ar(r,e,s);if(s.offset<t.length)throw new xe(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Vs=he.deserialize=Ta;function La(r,e,t,n=Le){const s=new n(t);return Ar(r,e,s)}Ds=he.deserializeUnchecked=La;var m={};Object.defineProperty(m,"__esModule",{value:!0});m.s16=m.s8=m.nu64be=m.u48be=m.u40be=m.u32be=m.u24be=m.u16be=de=m.nu64=m.u48=m.u40=q=m.u32=m.u24=Ce=m.u16=Y=m.u8=gt=m.offset=m.greedy=m.Constant=m.UTF8=m.CString=m.Blob=m.Boolean=m.BitField=m.BitStructure=m.VariantLayout=m.Union=m.UnionLayoutDiscriminator=m.UnionDiscriminator=m.Structure=m.Sequence=m.DoubleBE=m.Double=m.FloatBE=m.Float=m.NearInt64BE=m.NearInt64=m.NearUInt64BE=m.NearUInt64=m.IntBE=m.Int=m.UIntBE=m.UInt=m.OffsetLayout=m.GreedyCount=m.ExternalLayout=m.bindConstructorLayout=m.nameWithProperty=m.Layout=m.uint8ArrayToBuffer=m.checkUint8Array=void 0;m.constant=m.utf8=m.cstr=ne=m.blob=m.unionLayoutDiscriminator=m.union=be=m.seq=m.bits=U=m.struct=m.f64be=m.f64=m.f32be=m.f32=m.ns64be=m.s48be=m.s40be=m.s32be=m.s24be=m.s16be=Ie=m.ns64=m.s48=m.s40=m.s32=m.s24=void 0;const Er=ti;function Pt(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}m.checkUint8Array=Pt;function X(r){return Pt(r),Er.Buffer.from(r.buffer,r.byteOffset,r.length)}m.uint8ArrayToBuffer=X;class Q{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}m.Layout=Q;function Ir(r,e){return e.property?r+"["+e.property+"]":r}m.nameWithProperty=Ir;function Pa(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof Q))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}m.bindConstructorLayout=Pa;class ke extends Q{isCount(){throw new Error("ExternalLayout is abstract")}}m.ExternalLayout=ke;class Js extends ke{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Pt(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}m.GreedyCount=Js;class Br extends ke{constructor(e,t=0,n){if(!(e instanceof Q))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Ue||this.layout instanceof Ne}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}m.OffsetLayout=Br;class Ue extends Q{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return X(e).readUIntLE(t,this.span)}encode(e,t,n=0){return X(t).writeUIntLE(e,n,this.span),this.span}}m.UInt=Ue;class Ne extends Q{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return X(e).readUIntBE(t,this.span)}encode(e,t,n=0){return X(t).writeUIntBE(e,n,this.span),this.span}}m.UIntBE=Ne;class wt extends Q{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return X(e).readIntLE(t,this.span)}encode(e,t,n=0){return X(t).writeIntLE(e,n,this.span),this.span}}m.Int=wt;class Ct extends Q{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return X(e).readIntBE(t,this.span)}encode(e,t,n=0){return X(t).writeIntBE(e,n,this.span),this.span}}m.IntBE=Ct;const cr=Math.pow(2,32);function Cn(r){const e=Math.floor(r/cr),t=r-e*cr;return{hi32:e,lo32:t}}function On(r,e){return r*cr+e}class Zs extends Q{constructor(e){super(8,e)}decode(e,t=0){const n=X(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return On(o,s)}encode(e,t,n=0){const s=Cn(e),o=X(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}m.NearUInt64=Zs;class Xs extends Q{constructor(e){super(8,e)}decode(e,t=0){const n=X(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return On(s,o)}encode(e,t,n=0){const s=Cn(e),o=X(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}m.NearUInt64BE=Xs;class Ys extends Q{constructor(e){super(8,e)}decode(e,t=0){const n=X(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return On(o,s)}encode(e,t,n=0){const s=Cn(e),o=X(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}m.NearInt64=Ys;class Qs extends Q{constructor(e){super(8,e)}decode(e,t=0){const n=X(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return On(s,o)}encode(e,t,n=0){const s=Cn(e),o=X(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}m.NearInt64BE=Qs;class eo extends Q{constructor(e){super(4,e)}decode(e,t=0){return X(e).readFloatLE(t)}encode(e,t,n=0){return X(t).writeFloatLE(e,n),4}}m.Float=eo;class to extends Q{constructor(e){super(4,e)}decode(e,t=0){return X(e).readFloatBE(t)}encode(e,t,n=0){return X(t).writeFloatBE(e,n),4}}m.FloatBE=to;class no extends Q{constructor(e){super(8,e)}decode(e,t=0){return X(e).readDoubleLE(t)}encode(e,t,n=0){return X(t).writeDoubleLE(e,n),8}}m.Double=no;class ro extends Q{constructor(e){super(8,e)}decode(e,t=0){return X(e).readDoubleBE(t)}encode(e,t,n=0){return X(t).writeDoubleBE(e,n),8}}m.DoubleBE=ro;class so extends Q{constructor(e,t,n){if(!(e instanceof Q))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ke&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof ke)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof ke&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof ke&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof ke&&this.count.encode(e.length,t,n),o}}m.Sequence=so;class oo extends Q{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof Q,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Pt(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}m.Structure=oo;class Rr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}m.UnionDiscriminator=Rr;class bn extends Rr{constructor(e,t){if(!(e instanceof ke&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}m.UnionLayoutDiscriminator=bn;class Tr extends Q{constructor(e,t,n){let s;if(e instanceof Ue||e instanceof Ne)s=new bn(new Br(e));else if(e instanceof ke&&e.isCount())s=new bn(e);else if(e instanceof Rr)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof Q))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Ue||e instanceof Ne)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Ue||e instanceof Ne,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new io(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}m.Union=Tr;class io extends Q{constructor(e,t,n,s){if(!(e instanceof Tr))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof Q))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}m.VariantLayout=io;function _t(r){return 0>r&&(r+=4294967296),r}class Lr extends Q{constructor(e,t,n){if(!(e instanceof Ue||e instanceof Ne))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=_t(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new Pr(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new ao(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}m.BitStructure=Lr;class Pr{constructor(e,t,n){if(!(e instanceof Lr))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=_t(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return _t(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==_t(e&this.valueMask))throw new TypeError(Ir("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=_t(e<<this.start);this.container._packedSetValue(_t(t&~this.wordMask)|n)}}m.BitField=Pr;let ao=class extends Pr{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};m.Boolean=ao;class co extends Q{constructor(e,t){if(!(e instanceof ke&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof ke||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),X(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof ke&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Ir("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=X(e);return X(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof ke&&this.length.encode(s,t,n),s}}m.Blob=co;class uo extends Q{constructor(e){super(-1,e)}getSpan(e,t=0){Pt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return X(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Er.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=X(t);return s.copy(i,n),i[n+o]=0,o+1}}m.CString=uo;class lo extends Q{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Pt(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return X(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Er.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(X(t),n),o}}m.UTF8=lo;class fo extends Q{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}m.Constant=fo;m.greedy=(r,e)=>new Js(r,e);var gt=m.offset=(r,e,t)=>new Br(r,e,t),Y=m.u8=r=>new Ue(1,r),Ce=m.u16=r=>new Ue(2,r);m.u24=r=>new Ue(3,r);var q=m.u32=r=>new Ue(4,r);m.u40=r=>new Ue(5,r);m.u48=r=>new Ue(6,r);var de=m.nu64=r=>new Zs(r);m.u16be=r=>new Ne(2,r);m.u24be=r=>new Ne(3,r);m.u32be=r=>new Ne(4,r);m.u40be=r=>new Ne(5,r);m.u48be=r=>new Ne(6,r);m.nu64be=r=>new Xs(r);m.s8=r=>new wt(1,r);m.s16=r=>new wt(2,r);m.s24=r=>new wt(3,r);m.s32=r=>new wt(4,r);m.s40=r=>new wt(5,r);m.s48=r=>new wt(6,r);var Ie=m.ns64=r=>new Ys(r);m.s16be=r=>new Ct(2,r);m.s24be=r=>new Ct(3,r);m.s32be=r=>new Ct(4,r);m.s40be=r=>new Ct(5,r);m.s48be=r=>new Ct(6,r);m.ns64be=r=>new Qs(r);m.f32=r=>new eo(r);m.f32be=r=>new to(r);m.f64=r=>new no(r);m.f64be=r=>new ro(r);var U=m.struct=(r,e,t)=>new oo(r,e,t);m.bits=(r,e,t)=>new Lr(r,e,t);var be=m.seq=(r,e,t)=>new so(r,e,t);m.union=(r,e,t)=>new Tr(r,e,t);m.unionLayoutDiscriminator=(r,e)=>new bn(r,e);var ne=m.blob=(r,e)=>new co(r,e);m.cstr=r=>new uo(r);m.utf8=(r,e)=>new lo(r,e);m.constant=(r,e)=>new fo(r,e);var Yt={};Object.defineProperty(Yt,"__esModule",{value:!0});function Ca(r){{const e=O.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Oa=Yt.toBigIntLE=Ca;function Ua(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Yt.toBigIntBE=Ua;function Na(r,e){{const t=r.toString(16),n=O.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var Ma=Yt.toBufferLE=Na;function Fa(r,e){{const t=r.toString(16);return O.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Yt.toBufferBE=Fa;class qa extends TypeError{constructor(e,t){let n;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[e,...t()]}}}function Ha(r){return ct(r)&&typeof r[Symbol.iterator]=="function"}function ct(r){return typeof r=="object"&&r!=null}function Me(r){return typeof r=="string"?JSON.stringify(r):""+r}function Ka(r){const{done:e,value:t}=r.next();return e?void 0:t}function Da(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+Me(n)+"`"}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Qr(r,e,t,n){Ha(r)||(r=[r]);for(const s of r){const o=Da(s,e,t,n);o&&(yield o)}}function*Cr(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s};if(o&&(r=e.coercer(r,a),i&&e.type!=="type"&&ct(e.schema)&&ct(r)&&!Array.isArray(r)))for(const u in r)e.schema[u]===void 0&&delete r[u];let c=!0;for(const u of e.validator(r,a))c=!1,yield[u,void 0];for(let[u,f,l]of e.entries(r,a)){const w=Cr(f,l,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,f],coerce:o,mask:i});for(const d of w)d[0]?(c=!1,yield[d[0],void 0]):o&&(f=d[1],u===void 0?r=f:r instanceof Map?r.set(u,f):r instanceof Set?r.add(f):ct(r)&&(r[u]=f))}if(c)for(const u of e.refiner(r,a))c=!1,yield[u,void 0];c&&(yield[void 0,r])}let Ge=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const f=s(c,u);return Qr(f,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const f=o(c,u);return Qr(f,u,this,c)}:this.refiner=()=>[]}assert(e){return za(e,this)}create(e){return B(e,this)}is(e){return ho(e,this)}mask(e){return ja(e,this)}validate(e,t={}){return Qt(e,this,t)}};function za(r,e){const t=Qt(r,e);if(t[0])throw t[0]}function B(r,e){const t=Qt(r,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function ja(r,e){const t=Qt(r,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function ho(r,e){return!Qt(r,e)[0]}function Qt(r,e,t={}){const n=Cr(r,e,t),s=Ka(n);return s[0]?[new qa(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function bt(r,e){return new Ge({type:r,schema:null,validator:e})}function $a(){return bt("any",()=>!0)}function T(r){return new Ge({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+Me(e)}})}function Je(){return bt("boolean",r=>typeof r=="boolean")}function Or(r){return bt("instance",e=>e instanceof r||"Expected a `"+r.name+"` instance, but received: "+Me(e))}function ie(r){const e=Me(r),t=typeof r;return new Ge({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+e+"`, but received: "+Me(n)}})}function Wa(){return bt("never",()=>!1)}function L(r){return new Ge({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function g(){return bt("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+Me(r))}function K(r){return new Ge({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function po(r,e){return new Ge({type:"record",schema:null,*entries(t){if(ct(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return ct(t)||"Expected an object, but received: "+Me(t)}})}function E(){return bt("string",r=>typeof r=="string"||"Expected a string, but received: "+Me(r))}function Ur(r){const e=Wa();return new Ge({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+Me(t)}})}function _(r){const e=Object.keys(r);return new Ge({type:"type",schema:r,*entries(t){if(ct(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return ct(t)||"Expected an object, but received: "+Me(t)}})}function Ae(r){const e=r.map(t=>t.type).join(" | ");return new Ge({type:"union",schema:null,validator(t,n){const s=[];for(const o of r){const[...i]=Cr(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+Me(t),...s]}})}function en(){return bt("unknown",()=>!0)}function tn(r,e,t){return new Ge({...r,coercer:(n,s)=>ho(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var sn,Ga=new Uint8Array(16);function go(){if(!sn&&(sn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!sn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return sn(Ga)}const Va=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Un(r){return typeof r=="string"&&Va.test(r)}var fe=[];for(var Jn=0;Jn<256;++Jn)fe.push((Jn+256).toString(16).substr(1));function Nn(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(fe[r[e+0]]+fe[r[e+1]]+fe[r[e+2]]+fe[r[e+3]]+"-"+fe[r[e+4]]+fe[r[e+5]]+"-"+fe[r[e+6]]+fe[r[e+7]]+"-"+fe[r[e+8]]+fe[r[e+9]]+"-"+fe[r[e+10]]+fe[r[e+11]]+fe[r[e+12]]+fe[r[e+13]]+fe[r[e+14]]+fe[r[e+15]]).toLowerCase();if(!Un(t))throw TypeError("Stringified UUID is invalid");return t}var es,Zn,Xn=0,Yn=0;function Ja(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||es,i=r.clockseq!==void 0?r.clockseq:Zn;if(o==null||i==null){var a=r.random||(r.rng||go)();o==null&&(o=es=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Zn=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:Yn+1,f=c-Xn+(u-Yn)/1e4;if(f<0&&r.clockseq===void 0&&(i=i+1&16383),(f<0||c>Xn)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Xn=c,Yn=u,Zn=i,c+=122192928e5;var l=((c&268435455)*1e4+u)%4294967296;s[n++]=l>>>24&255,s[n++]=l>>>16&255,s[n++]=l>>>8&255,s[n++]=l&255;var w=c/4294967296*1e4&268435455;s[n++]=w>>>8&255,s[n++]=w&255,s[n++]=w>>>24&15|16,s[n++]=w>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var d=0;d<6;++d)s[n+d]=o[d];return e||Nn(s)}function yo(r){if(!Un(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Za(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var Xa="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Ya="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function mo(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=Za(s)),typeof o=="string"&&(o=yo(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Nn(c)}try{n.name=r}catch{}return n.DNS=Xa,n.URL=Ya,n}function Qa(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return ec(tc(nc(r),r.length*8))}function ec(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function wo(r){return(r+64>>>9<<4)+14+1}function tc(r,e){r[e>>5]|=128<<e%32,r[wo(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,u=s,f=o;t=ge(t,n,s,o,r[i],7,-680876936),o=ge(o,t,n,s,r[i+1],12,-389564586),s=ge(s,o,t,n,r[i+2],17,606105819),n=ge(n,s,o,t,r[i+3],22,-1044525330),t=ge(t,n,s,o,r[i+4],7,-176418897),o=ge(o,t,n,s,r[i+5],12,1200080426),s=ge(s,o,t,n,r[i+6],17,-1473231341),n=ge(n,s,o,t,r[i+7],22,-45705983),t=ge(t,n,s,o,r[i+8],7,1770035416),o=ge(o,t,n,s,r[i+9],12,-1958414417),s=ge(s,o,t,n,r[i+10],17,-42063),n=ge(n,s,o,t,r[i+11],22,-1990404162),t=ge(t,n,s,o,r[i+12],7,1804603682),o=ge(o,t,n,s,r[i+13],12,-40341101),s=ge(s,o,t,n,r[i+14],17,-1502002290),n=ge(n,s,o,t,r[i+15],22,1236535329),t=ye(t,n,s,o,r[i+1],5,-165796510),o=ye(o,t,n,s,r[i+6],9,-1069501632),s=ye(s,o,t,n,r[i+11],14,643717713),n=ye(n,s,o,t,r[i],20,-373897302),t=ye(t,n,s,o,r[i+5],5,-701558691),o=ye(o,t,n,s,r[i+10],9,38016083),s=ye(s,o,t,n,r[i+15],14,-660478335),n=ye(n,s,o,t,r[i+4],20,-405537848),t=ye(t,n,s,o,r[i+9],5,568446438),o=ye(o,t,n,s,r[i+14],9,-1019803690),s=ye(s,o,t,n,r[i+3],14,-187363961),n=ye(n,s,o,t,r[i+8],20,1163531501),t=ye(t,n,s,o,r[i+13],5,-1444681467),o=ye(o,t,n,s,r[i+2],9,-51403784),s=ye(s,o,t,n,r[i+7],14,1735328473),n=ye(n,s,o,t,r[i+12],20,-1926607734),t=me(t,n,s,o,r[i+5],4,-378558),o=me(o,t,n,s,r[i+8],11,-2022574463),s=me(s,o,t,n,r[i+11],16,1839030562),n=me(n,s,o,t,r[i+14],23,-35309556),t=me(t,n,s,o,r[i+1],4,-1530992060),o=me(o,t,n,s,r[i+4],11,1272893353),s=me(s,o,t,n,r[i+7],16,-155497632),n=me(n,s,o,t,r[i+10],23,-1094730640),t=me(t,n,s,o,r[i+13],4,681279174),o=me(o,t,n,s,r[i],11,-358537222),s=me(s,o,t,n,r[i+3],16,-722521979),n=me(n,s,o,t,r[i+6],23,76029189),t=me(t,n,s,o,r[i+9],4,-640364487),o=me(o,t,n,s,r[i+12],11,-421815835),s=me(s,o,t,n,r[i+15],16,530742520),n=me(n,s,o,t,r[i+2],23,-995338651),t=we(t,n,s,o,r[i],6,-198630844),o=we(o,t,n,s,r[i+7],10,1126891415),s=we(s,o,t,n,r[i+14],15,-1416354905),n=we(n,s,o,t,r[i+5],21,-57434055),t=we(t,n,s,o,r[i+12],6,1700485571),o=we(o,t,n,s,r[i+3],10,-1894986606),s=we(s,o,t,n,r[i+10],15,-1051523),n=we(n,s,o,t,r[i+1],21,-2054922799),t=we(t,n,s,o,r[i+8],6,1873313359),o=we(o,t,n,s,r[i+15],10,-30611744),s=we(s,o,t,n,r[i+6],15,-1560198380),n=we(n,s,o,t,r[i+13],21,1309151649),t=we(t,n,s,o,r[i+4],6,-145523070),o=we(o,t,n,s,r[i+11],10,-1120210379),s=we(s,o,t,n,r[i+2],15,718787259),n=we(n,s,o,t,r[i+9],21,-343485551),t=at(t,a),n=at(n,c),s=at(s,u),o=at(o,f)}return[t,n,s,o]}function nc(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(wo(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function at(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function rc(r,e){return r<<e|r>>>32-e}function Mn(r,e,t,n,s,o){return at(rc(at(at(e,r),at(n,o)),s),t)}function ge(r,e,t,n,s,o,i){return Mn(e&t|~e&n,r,e,s,o,i)}function ye(r,e,t,n,s,o,i){return Mn(e&n|t&~n,r,e,s,o,i)}function me(r,e,t,n,s,o,i){return Mn(e^t^n,r,e,s,o,i)}function we(r,e,t,n,s,o,i){return Mn(t^(e|~n),r,e,s,o,i)}var sc=mo("v3",48,Qa);const oc=sc;function ic(r,e,t){r=r||{};var n=r.random||(r.rng||go)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return Nn(n)}function ac(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Qn(r,e){return r<<e|r>>>32-e}function cc(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),f=0;f<16;++f)u[f]=r[c*64+f*4]<<24|r[c*64+f*4+1]<<16|r[c*64+f*4+2]<<8|r[c*64+f*4+3];a[c]=u}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var l=0;l<i;++l){for(var w=new Uint32Array(80),d=0;d<16;++d)w[d]=a[l][d];for(var h=16;h<80;++h)w[h]=Qn(w[h-3]^w[h-8]^w[h-14]^w[h-16],1);for(var p=t[0],y=t[1],x=t[2],S=t[3],b=t[4],C=0;C<80;++C){var k=Math.floor(C/20),M=Qn(p,5)+ac(k,y,x,S)+b+e[k]+w[C]>>>0;b=S,S=x,x=Qn(y,30)>>>0,y=p,p=M}t[0]=t[0]+p>>>0,t[1]=t[1]+y>>>0,t[2]=t[2]+x>>>0,t[3]=t[3]+S>>>0,t[4]=t[4]+b>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var uc=mo("v5",80,cc);const lc=uc,fc="00000000-0000-0000-0000-000000000000";function dc(r){if(!Un(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const hc=Object.freeze(Object.defineProperty({__proto__:null,NIL:fc,parse:yo,stringify:Nn,v1:Ja,v3:oc,v4:ic,v5:lc,validate:Un,version:dc},Symbol.toStringTag,{value:"Module"})),bo=Is(hc),pc=bo.v4,gc=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return pc()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var yc=gc;const mc=bo.v4,wc=yc,jt=function(r,e){if(!(this instanceof jt))return new jt(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return mc()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var bc=jt;jt.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=wc(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(f){if(u)return n(f);throw f}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,f){s._parseResponse(u,f,n)}),o};jt.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};var vo={},vn={},vc={get exports(){return vn},set exports(r){vn=r}};(function(r){function e(t){return t&&t.__esModule?t:{default:t}}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports})(vc);var xn={},xc={get exports(){return xn},set exports(r){xn=r}},Sn={},Sc={get exports(){return Sn},set exports(r){Sn=r}},ts;function _c(){return ts||(ts=1,function(r){function e(t,n){return r.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},r.exports.__esModule=!0,r.exports.default=r.exports,e(t,n)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Sc)),Sn}var ns;function xo(){return ns||(ns=1,function(r){var e=_c();function t(n,s){if(typeof s!="function"&&s!==null)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(s&&s.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),s&&e(n,s)}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(xc)),xn}var _n={},kc={get exports(){return _n},set exports(r){_n=r}},kn={},Ac={get exports(){return kn},set exports(r){kn=r}},rs;function Ec(){return rs||(rs=1,function(r){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Ac)),kn}var ss;function So(){return ss||(ss=1,function(r){var e=pr().default,t=Ec();function n(s,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(s)}r.exports=n,r.exports.__esModule=!0,r.exports.default=r.exports}(kc)),_n}var An={},Ic={get exports(){return An},set exports(r){An=r}},os;function _o(){return os||(os=1,function(r){function e(t){return r.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(s){return s.__proto__||Object.getPrototypeOf(s)},r.exports.__esModule=!0,r.exports.default=r.exports,e(t)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Ic)),An}var En={},Bc={get exports(){return En},set exports(r){En=r}},is;function ko(){return is||(is=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,f){this.fn=c,this.context=u,this.once=f||!1}function o(c,u,f,l,w){if(typeof f!="function")throw new TypeError("The listener must be a function");var d=new s(f,l||c,w),h=t?t+u:u;return c._events[h]?c._events[h].fn?c._events[h]=[c._events[h],d]:c._events[h].push(d):(c._events[h]=d,c._eventsCount++),c}function i(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],f,l;if(this._eventsCount===0)return u;for(l in f=this._events)e.call(f,l)&&u.push(t?l.slice(1):l);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(f)):u},a.prototype.listeners=function(u){var f=t?t+u:u,l=this._events[f];if(!l)return[];if(l.fn)return[l.fn];for(var w=0,d=l.length,h=new Array(d);w<d;w++)h[w]=l[w].fn;return h},a.prototype.listenerCount=function(u){var f=t?t+u:u,l=this._events[f];return l?l.fn?1:l.length:0},a.prototype.emit=function(u,f,l,w,d,h){var p=t?t+u:u;if(!this._events[p])return!1;var y=this._events[p],x=arguments.length,S,b;if(y.fn){switch(y.once&&this.removeListener(u,y.fn,void 0,!0),x){case 1:return y.fn.call(y.context),!0;case 2:return y.fn.call(y.context,f),!0;case 3:return y.fn.call(y.context,f,l),!0;case 4:return y.fn.call(y.context,f,l,w),!0;case 5:return y.fn.call(y.context,f,l,w,d),!0;case 6:return y.fn.call(y.context,f,l,w,d,h),!0}for(b=1,S=new Array(x-1);b<x;b++)S[b-1]=arguments[b];y.fn.apply(y.context,S)}else{var C=y.length,k;for(b=0;b<C;b++)switch(y[b].once&&this.removeListener(u,y[b].fn,void 0,!0),x){case 1:y[b].fn.call(y[b].context);break;case 2:y[b].fn.call(y[b].context,f);break;case 3:y[b].fn.call(y[b].context,f,l);break;case 4:y[b].fn.call(y[b].context,f,l,w);break;default:if(!S)for(k=1,S=new Array(x-1);k<x;k++)S[k-1]=arguments[k];y[b].fn.apply(y[b].context,S)}}return!0},a.prototype.on=function(u,f,l){return o(this,u,f,l,!1)},a.prototype.once=function(u,f,l){return o(this,u,f,l,!0)},a.prototype.removeListener=function(u,f,l,w){var d=t?t+u:u;if(!this._events[d])return this;if(!f)return i(this,d),this;var h=this._events[d];if(h.fn)h.fn===f&&(!w||h.once)&&(!l||h.context===l)&&i(this,d);else{for(var p=0,y=[],x=h.length;p<x;p++)(h[p].fn!==f||w&&!h[p].once||l&&h[p].context!==l)&&y.push(h[p]);y.length?this._events[d]=y.length===1?y[0]:y:i(this,d)}return this},a.prototype.removeAllListeners=function(u){var f;return u?(f=t?t+u:u,this._events[f]&&i(this,f)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(Bc)),En}(function(r){var e=vn;Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var t=e(ci()),n=e(oi()),s=e(pr()),o=e(Bs()),i=e(Rs()),a=e(xo()),c=e(So()),u=e(_o()),f=ko();function l(p){var y=w();return function(){var S=(0,u.default)(p),b;if(y){var C=(0,u.default)(this).constructor;b=Reflect.construct(S,arguments,C)}else b=S.apply(this,arguments);return(0,c.default)(this,b)}}function w(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var d=function(p,y){var x={};for(var S in p)Object.prototype.hasOwnProperty.call(p,S)&&y.indexOf(S)<0&&(x[S]=p[S]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var b=0,S=Object.getOwnPropertySymbols(p);b<S.length;b++)y.indexOf(S[b])<0&&Object.prototype.propertyIsEnumerable.call(p,S[b])&&(x[S[b]]=p[S[b]]);return x},h=function(p){(0,a.default)(x,p);var y=l(x);function x(S){var b,C=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",k=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},M=arguments.length>3?arguments[3]:void 0;(0,o.default)(this,x);var P=k.autoconnect,F=P===void 0?!0:P,te=k.reconnect,Se=te===void 0?!0:te,Pe=k.reconnect_interval,Ee=Pe===void 0?1e3:Pe,Fe=k.max_reconnects,St=Fe===void 0?5:Fe,R=d(k,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return b=y.call(this),b.webSocketFactory=S,b.queue={},b.rpc_id=0,b.address=C,b.autoconnect=F,b.ready=!1,b.reconnect=Se,b.reconnect_timer_id=void 0,b.reconnect_interval=Ee,b.max_reconnects=St,b.rest_options=R,b.current_reconnects=0,b.generate_request_id=M||function(){return++b.rpc_id},b.autoconnect&&b._connect(b.address,Object.assign({autoconnect:b.autoconnect,reconnect:b.reconnect,reconnect_interval:b.reconnect_interval,max_reconnects:b.max_reconnects},b.rest_options)),b}return(0,i.default)(x,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(b,C,k,M){var P=this;return!M&&(0,s.default)(k)==="object"&&(M=k,k=null),new Promise(function(F,te){if(!P.ready)return te(new Error("socket not ready"));var Se=P.generate_request_id(b,C),Pe={jsonrpc:"2.0",method:b,params:C||null,id:Se};P.socket.send(JSON.stringify(Pe),M,function(Ee){if(Ee)return te(Ee);P.queue[Se]={promise:[F,te]},k&&(P.queue[Se].timeout=setTimeout(function(){delete P.queue[Se],te(new Error("reply timeout"))},k))})})}},{key:"login",value:function(){var S=(0,n.default)(t.default.mark(function C(k){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return F.next=2,this.call("rpc.login",k);case 2:if(M=F.sent,M){F.next=5;break}throw new Error("authentication failed");case 5:return F.abrupt("return",M);case 6:case"end":return F.stop()}},C,this)}));function b(C){return S.apply(this,arguments)}return b}()},{key:"listMethods",value:function(){var S=(0,n.default)(t.default.mark(function C(){return t.default.wrap(function(M){for(;;)switch(M.prev=M.next){case 0:return M.next=2,this.call("__listMethods");case 2:return M.abrupt("return",M.sent);case 3:case"end":return M.stop()}},C,this)}));function b(){return S.apply(this,arguments)}return b}()},{key:"notify",value:function(b,C){var k=this;return new Promise(function(M,P){if(!k.ready)return P(new Error("socket not ready"));var F={jsonrpc:"2.0",method:b,params:C||null};k.socket.send(JSON.stringify(F),function(te){if(te)return P(te);M()})})}},{key:"subscribe",value:function(){var S=(0,n.default)(t.default.mark(function C(k){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return typeof k=="string"&&(k=[k]),F.next=3,this.call("rpc.on",k);case 3:if(M=F.sent,!(typeof k=="string"&&M[k]!=="ok")){F.next=6;break}throw new Error("Failed subscribing to an event '"+k+"' with: "+M[k]);case 6:return F.abrupt("return",M);case 7:case"end":return F.stop()}},C,this)}));function b(C){return S.apply(this,arguments)}return b}()},{key:"unsubscribe",value:function(){var S=(0,n.default)(t.default.mark(function C(k){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return typeof k=="string"&&(k=[k]),F.next=3,this.call("rpc.off",k);case 3:if(M=F.sent,!(typeof k=="string"&&M[k]!=="ok")){F.next=6;break}throw new Error("Failed unsubscribing from an event with: "+M);case 6:return F.abrupt("return",M);case 7:case"end":return F.stop()}},C,this)}));function b(C){return S.apply(this,arguments)}return b}()},{key:"close",value:function(b,C){this.socket.close(b||1e3,C)}},{key:"_connect",value:function(b,C){var k=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(b,C),this.socket.addEventListener("open",function(){k.ready=!0,k.emit("open"),k.current_reconnects=0}),this.socket.addEventListener("message",function(M){var P=M.data;P instanceof ArrayBuffer&&(P=O.from(P).toString());try{P=JSON.parse(P)}catch{return}if(P.notification&&k.listeners(P.notification).length){if(!Object.keys(P.params).length)return k.emit(P.notification);var F=[P.notification];if(P.params.constructor===Object)F.push(P.params);else for(var te=0;te<P.params.length;te++)F.push(P.params[te]);return Promise.resolve().then(function(){k.emit.apply(k,F)})}if(!k.queue[P.id])return P.method&&P.params?Promise.resolve().then(function(){k.emit(P.method,P.params)}):void 0;"error"in P=="result"in P&&k.queue[P.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),k.queue[P.id].timeout&&clearTimeout(k.queue[P.id].timeout),P.error?k.queue[P.id].promise[1](P.error):k.queue[P.id].promise[0](P.result),delete k.queue[P.id]}),this.socket.addEventListener("error",function(M){return k.emit("error",M)}),this.socket.addEventListener("close",function(M){var P=M.code,F=M.reason;k.ready&&setTimeout(function(){return k.emit("close",P,F)},0),k.ready=!1,k.socket=void 0,P!==1e3&&(k.current_reconnects++,k.reconnect&&(k.max_reconnects>k.current_reconnects||k.max_reconnects===0)&&(k.reconnect_timer_id=setTimeout(function(){return k._connect(b,C)},k.reconnect_interval)))})}}]),x}(f.EventEmitter);r.default=h})(vo);const Rc=Ts(vo);var Ao={};(function(r){var e=vn;Object.defineProperty(r,"__esModule",{value:!0}),r.default=l;var t=e(Bs()),n=e(Rs()),s=e(xo()),o=e(So()),i=e(_o()),a=ko();function c(w){var d=u();return function(){var p=(0,i.default)(w),y;if(d){var x=(0,i.default)(this).constructor;y=Reflect.construct(p,arguments,x)}else y=p.apply(this,arguments);return(0,o.default)(this,y)}}function u(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var f=function(w){(0,s.default)(h,w);var d=c(h);function h(p,y,x){var S;return(0,t.default)(this,h),S=d.call(this),S.socket=new window.WebSocket(p,x),S.socket.onopen=function(){return S.emit("open")},S.socket.onmessage=function(b){return S.emit("message",b.data)},S.socket.onerror=function(b){return S.emit("error",b)},S.socket.onclose=function(b){S.emit("close",b.code,b.reason)},S}return(0,n.default)(h,[{key:"send",value:function(y,x,S){var b=S||x;try{this.socket.send(y),b()}catch(C){b(C)}}},{key:"close",value:function(y,x){this.socket.close(y,x)}},{key:"addEventListener",value:function(y,x,S){this.socket.addEventListener(y,x,S)}}]),h}(a.EventEmitter);function l(w,d){return new f(w,d)}})(Ao);const Tc=Ts(Ao),[Eo,Io,Bo]=[[],[],[]],Lc=BigInt(0),Ut=BigInt(1),Pc=BigInt(2),Cc=BigInt(7),Oc=BigInt(256),Uc=BigInt(113);for(let r=0,e=Ut,t=1,n=0;r<24;r++){[t,n]=[n,(2*t+3*n)%5],Eo.push(2*(5*n+t)),Io.push((r+1)*(r+2)/2%64);let s=Lc;for(let o=0;o<7;o++)e=(e<<Ut^(e>>Cc)*Uc)%Oc,e&Pc&&(s^=Ut<<(Ut<<BigInt(o))-Ut);Bo.push(s)}const[Nc,Mc]=j.split(Bo,!0),as=(r,e,t)=>t>32?j.rotlBH(r,e,t):j.rotlSH(r,e,t),cs=(r,e,t)=>t>32?j.rotlBL(r,e,t):j.rotlSL(r,e,t);function Fc(r,e=24){const t=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)t[i]=r[i]^r[i+10]^r[i+20]^r[i+30]^r[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,u=t[c],f=t[c+1],l=as(u,f,1)^t[a],w=cs(u,f,1)^t[a+1];for(let d=0;d<50;d+=10)r[i+d]^=l,r[i+d+1]^=w}let s=r[2],o=r[3];for(let i=0;i<24;i++){const a=Io[i],c=as(s,o,a),u=cs(s,o,a),f=Eo[i];s=r[f],o=r[f+1],r[f]=c,r[f+1]=u}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=r[i+a];for(let a=0;a<10;a++)r[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}r[0]^=Nc[n],r[1]^=Mc[n]}t.fill(0)}class Fn extends br{constructor(e,t,n,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Te.number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=mi(this.state)}keccak(){Fc(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){Te.exists(this);const{blockLen:t,state:n}=this;e=Jt(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,t&128&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Te.exists(this,!1),Te.bytes(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Te.number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Te.output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new Fn(t,n,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const lt=(r,e,t)=>mt(()=>new Fn(e,r,t));lt(6,144,224/8);lt(6,136,256/8);lt(6,104,384/8);lt(6,72,512/8);lt(1,144,224/8);lt(1,136,256/8);lt(1,104,384/8);lt(1,72,512/8);const Ro=(r,e,t)=>vi((n={})=>new Fn(e,r,n.dkLen===void 0?t:n.dkLen,!0));Ro(31,168,128/8);Ro(31,136,256/8);class To extends br{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Te.hash(e);const n=Jt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Te.exists(this),this.iHash.update(e),this}digestInto(e){Te.exists(this),Te.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Lo=(r,e,t)=>new To(r,e).update(t).digest();Lo.create=(r,e)=>new To(r,e);yt.sha512Sync=(...r)=>Vi(yt.concatBytes(...r));yt.randomPrivateKey;const us=()=>{const r=yt.randomPrivateKey(),e=ur(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},ur=_r.getPublicKey;function ls(r){try{return ae.fromHex(r,!0),!0}catch{return!1}}const Po=(r,e)=>_r.sign(r,e.slice(0,32)),qc=_r.verify,Rt=r=>O.isBuffer(r)?r:r instanceof Uint8Array?O.from(r.buffer,r.byteOffset,r.byteLength):O.from(r);class Hc{constructor(e){Object.assign(this,e)}encode(){return O.from(Gs(cn,this))}static decode(e){return Vs(cn,this,e)}static decodeUnchecked(e){return Ds(cn,this,e)}}const cn=new Map;let Co;const Kc=32,ze=32;function Dc(r){return r._bn!==void 0}let fs=1;Co=Symbol.toStringTag;class H extends Hc{constructor(e){if(super({}),this._bn=void 0,Dc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=ee.decode(e);if(t.length!=ze)throw new Error("Invalid public key input");this._bn=new zr(t)}else this._bn=new zr(e);if(this._bn.byteLength()>ze)throw new Error("Invalid public key input")}}static unique(){const e=new H(fs);return fs+=1,new H(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ee.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(O);if(e.length===ze)return e;const t=O.alloc(32);return e.copy(t,32-e.length),t}get[Co](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=O.concat([e.toBuffer(),O.from(t),n.toBuffer()]),o=ar(s);return new H(o)}static createProgramAddressSync(e,t){let n=O.alloc(0);e.forEach(function(o){if(o.length>Kc)throw new TypeError("Max seed length exceeded");n=O.concat([n,Rt(o)])}),n=O.concat([n,t.toBuffer(),O.from("ProgramDerivedAddress")]);const s=ar(n);if(ls(s))throw new Error("Invalid seeds, address must fall off the curve");return new H(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(O.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new H(e);return ls(t.toBytes())}}H.default=new H("11111111111111111111111111111111");cn.set(H,{kind:"struct",fields:[["_bn","u256"]]});new H("BPFLoader1111111111111111111111111111111111");const Et=1280-40-8,Nr=127,$t=64;class Oo extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Oo.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Uo extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Uo.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Mt extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Mt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class In{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const G=(r="publicKey")=>ne(32,r),zc=(r="signature")=>ne(64,r),At=(r="string")=>{const e=U([q("length"),q("lengthPadding"),ne(gt(q(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:O.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>q().span+q().span+O.from(o,"utf8").length,s},jc=(r="authorized")=>U([G("staker"),G("withdrawer")],r),$c=(r="lockup")=>U([Ie("unixTimestamp"),Ie("epoch"),G("custodian")],r),Wc=(r="voteInit")=>U([G("nodePubkey"),G("authorizedVoter"),G("authorizedWithdrawer"),Y("commission")],r),Gc=(r="voteAuthorizeWithSeedArgs")=>U([q("voteAuthorizationType"),G("currentAuthorityDerivedKeyOwnerPubkey"),At("currentAuthorityDerivedKeySeed"),G("newAuthorized")],r);function Be(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Re(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function se(r,e){if(!r)throw new Error(e||"Assertion failed")}class qn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new qn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];se(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{se(t.length>0,"Expected at least one writable signer key");const[c]=t[0];se(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new H(c)),...n.map(([c])=>new H(c)),...s.map(([c])=>new H(c)),...o.map(([c])=>new H(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new H(o),c=e.findIndex(u=>u.equals(a));c>=0&&(se(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}class Ze{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new H(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ee.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new In(this.staticAccountKeys)}static compile(e){const t=qn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new In(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ee.encode(a.data)}));return new Ze({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Re(t,e);const n=this.instructions.map(l=>{const{accounts:w,programIdIndex:d}=l,h=Array.from(ee.decode(l.data));let p=[];Re(p,w.length);let y=[];return Re(y,h.length),{programIdIndex:d,keyIndicesCount:O.from(p),keyIndices:w,dataLength:O.from(y),data:h}});let s=[];Re(s,n.length);let o=O.alloc(Et);O.from(s).copy(o);let i=s.length;n.forEach(l=>{const d=U([Y("programIdIndex"),ne(l.keyIndicesCount.length,"keyIndicesCount"),be(Y("keyIndex"),l.keyIndices.length,"keyIndices"),ne(l.dataLength.length,"dataLength"),be(Y("userdatum"),l.data.length,"data")]).encode(l,o,i);i+=d}),o=o.slice(0,i);const a=U([ne(1,"numRequiredSignatures"),ne(1,"numReadonlySignedAccounts"),ne(1,"numReadonlyUnsignedAccounts"),ne(t.length,"keyCount"),be(G("key"),e,"keys"),G("recentBlockhash")]),c={numRequiredSignatures:O.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:O.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:O.from([this.header.numReadonlyUnsignedAccounts]),keyCount:O.from(t),keys:this.accountKeys.map(l=>Rt(l.toBytes())),recentBlockhash:ee.decode(this.recentBlockhash)};let u=O.alloc(2048);const f=a.encode(c,u);return o.copy(u,f),u.slice(0,f+o.length)}static from(e){let t=[...e];const n=t.shift();if(n!==(n&Nr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=Be(t);let a=[];for(let w=0;w<i;w++){const d=t.slice(0,ze);t=t.slice(ze),a.push(new H(O.from(d)))}const c=t.slice(0,ze);t=t.slice(ze);const u=Be(t);let f=[];for(let w=0;w<u;w++){const d=t.shift(),h=Be(t),p=t.slice(0,h);t=t.slice(h);const y=Be(t),x=t.slice(0,y),S=ee.encode(O.from(x));t=t.slice(y),f.push({programIdIndex:d,accounts:p,data:S})}const l={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:ee.encode(O.from(c)),accountKeys:a,instructions:f};return new Ze(l)}}class Wt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new In(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=qn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const f of o){const l=t.extractTableLookup(f);if(l!==void 0){const[w,{writable:d,readonly:h}]=l;n.push(w),s.writable.push(...d),s.readonly.push(...h)}}const[i,a]=t.getMessageComponents(),u=new In(a,s).compileInstructions(e.instructions);return new Wt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();Re(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Re(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Re(o,this.addressTableLookups.length);const i=U([Y("prefix"),U([Y("numRequiredSignatures"),Y("numReadonlySignedAccounts"),Y("numReadonlyUnsignedAccounts")],"header"),ne(e.length,"staticAccountKeysLength"),be(G(),this.staticAccountKeys.length,"staticAccountKeys"),G("recentBlockhash"),ne(n.length,"instructionsLength"),ne(t.length,"serializedInstructions"),ne(o.length,"addressTableLookupsLength"),ne(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Et),c=1<<7,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(f=>f.toBytes()),recentBlockhash:ee.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Et);for(const n of this.compiledInstructions){const s=Array();Re(s,n.accountKeyIndexes.length);const o=Array();Re(o,n.data.length);const i=U([Y("programIdIndex"),ne(s.length,"encodedAccountKeyIndexesLength"),be(Y(),n.accountKeyIndexes.length,"accountKeyIndexes"),ne(o.length,"encodedDataLength"),ne(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Et);for(const n of this.addressTableLookups){const s=Array();Re(s,n.writableIndexes.length);const o=Array();Re(o,n.readonlyIndexes.length);const i=U([G("accountKey"),ne(s.length,"encodedWritableIndexesLength"),be(Y(),n.writableIndexes.length,"writableIndexes"),ne(o.length,"encodedReadonlyIndexesLength"),be(Y(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=t.shift(),s=n&Nr;se(n!==s,"Expected versioned message but received legacy message");const o=s;se(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Be(t);for(let h=0;h<c;h++)a.push(new H(t.splice(0,ze)));const u=ee.encode(t.splice(0,ze)),f=Be(t),l=[];for(let h=0;h<f;h++){const p=t.shift(),y=Be(t),x=t.splice(0,y),S=Be(t),b=new Uint8Array(t.splice(0,S));l.push({programIdIndex:p,accountKeyIndexes:x,data:b})}const w=Be(t),d=[];for(let h=0;h<w;h++){const p=new H(t.splice(0,ze)),y=Be(t),x=t.splice(0,y),S=Be(t),b=t.splice(0,S);d.push({accountKey:p,writableIndexes:x,readonlyIndexes:b})}return new Wt({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:l,addressTableLookups:d})}}const No={deserializeMessageVersion(r){const e=r[0],t=e&Nr;return t===e?"legacy":t},deserialize:r=>{const e=No.deserializeMessageVersion(r);if(e==="legacy")return Ze.from(r);if(e===0)return Wt.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let Ke;(function(r){r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID"})(Ke||(Ke={}));const Vc=O.alloc($t).fill(0);class ds{constructor(e){this.keys=void 0,this.programId=void 0,this.data=O.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class ot{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ds(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let p=0;p<t.length;p++)if(t[p].programId===void 0)throw new Error(`Transaction instruction index ${p} has undefined program id`);const s=[],o=[];t.forEach(p=>{p.keys.forEach(x=>{o.push({...x})});const y=p.programId.toString();s.includes(y)||s.push(y)}),s.forEach(p=>{o.push({pubkey:new H(p),isSigner:!1,isWritable:!1})});const i=[];o.forEach(p=>{const y=p.pubkey.toString(),x=i.findIndex(S=>S.pubkey.toString()===y);x>-1?(i[x].isWritable=i[x].isWritable||p.isWritable,i[x].isSigner=i[x].isSigner||p.isSigner):i.push(p)}),i.sort(function(p,y){return p.isSigner!==y.isSigner?p.isSigner?-1:1:p.isWritable!==y.isWritable?p.isWritable?-1:1:p.pubkey.toBase58().localeCompare(y.pubkey.toBase58())});const a=i.findIndex(p=>p.pubkey.equals(n));if(a>-1){const[p]=i.splice(a,1);p.isSigner=!0,p.isWritable=!0,i.unshift(p)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const p of this.signatures){const y=i.findIndex(x=>x.pubkey.equals(p.publicKey));if(y>-1)i[y].isSigner||(i[y].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${p.publicKey.toString()}`)}let c=0,u=0,f=0;const l=[],w=[];i.forEach(({pubkey:p,isSigner:y,isWritable:x})=>{y?(l.push(p.toString()),c+=1,x||(u+=1)):(w.push(p.toString()),x||(f+=1))});const d=l.concat(w),h=t.map(p=>{const{data:y,programId:x}=p;return{programIdIndex:d.indexOf(x.toString()),accounts:p.keys.map(S=>d.indexOf(S.pubkey.toString())),data:ee.encode(y)}});return h.forEach(p=>{se(p.programIdIndex>=0),p.accounts.forEach(y=>se(y>=0))}),new Ze({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:f},accountKeys:d,recentBlockhash:e,instructions:h})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=Po(n,s.secretKey);this._addSignature(s.publicKey,Rt(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){se(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=O.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:n,publicKey:s}of this.signatures)if(n===null){if(t)return!1}else if(!qc(n,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Re(n,t.length);const s=n.length+t.length*64+e.length,o=O.alloc(s);return se(t.length<256),O.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(se(i.length===64,"signature has invalid length"),O.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),se(o.length<=Et,`Transaction too large: ${o.length} > ${Et}`),o}get keys(){return se(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return se(this.instructions.length===1),this.instructions[0].programId}get data(){return se(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Be(t);let s=[];for(let o=0;o<n;o++){const i=t.slice(0,$t);t=t.slice($t),s.push(ee.encode(O.from(i)))}return ot.populate(Ze.from(t),s)}static populate(e,t=[]){const n=new ot;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==ee.encode(Vc)?null:ee.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new ds({keys:o,programId:e.accountKeys[s.programIdIndex],data:ee.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class It{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)se(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array($t));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Re(t,this.signatures.length);const n=U([ne(t.length,"encodedSignaturesLength"),be(zc(),this.signatures.length,"signatures"),ne(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const n=[],s=Be(t);for(let i=0;i<s;i++)n.push(new Uint8Array(t.splice(0,$t)));const o=No.deserialize(new Uint8Array(t));return new It(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=n.findIndex(i=>i.equals(s.publicKey));se(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=Po(t,s.secretKey)}}addSignature(e,t){se(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));se(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}new H("SysvarC1ock11111111111111111111111111111111");new H("SysvarEpochSchedu1e111111111111111111111111");new H("Sysvar1nstructions1111111111111111111111111");new H("SysvarRecentB1ockHashes11111111111111111111");new H("SysvarRent111111111111111111111111111111111");new H("SysvarRewards111111111111111111111111111111");new H("SysvarS1otHashes111111111111111111111111111");new H("SysvarS1otHistory11111111111111111111111111");new H("SysvarStakeHistory1111111111111111111111111");function kt(r){return new Promise(e=>setTimeout(e,r))}const Jc=de("lamportsPerSignature"),Mo=U([q("version"),q("state"),G("authorizedPubkey"),G("nonce"),U([Jc],"feeCalculator")]);Mo.span;class Mr{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Mo.decode(Rt(e),0);return new Mr({authorizedPubkey:new H(t.authorizedPubkey),nonce:new H(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Zc=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Xc=r=>e=>{const t=ne(r,e),{encode:n,decode:s}=Zc(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Oa(O.from(c))},o.encode=(i,a,c)=>{const u=Ma(i,r);return n(u,a,c)},o},Tt=Xc(8);Object.freeze({Create:{index:0,layout:U([q("instruction"),Ie("lamports"),Ie("space"),G("programId")])},Assign:{index:1,layout:U([q("instruction"),G("programId")])},Transfer:{index:2,layout:U([q("instruction"),Tt("lamports")])},CreateWithSeed:{index:3,layout:U([q("instruction"),G("base"),At("seed"),Ie("lamports"),Ie("space"),G("programId")])},AdvanceNonceAccount:{index:4,layout:U([q("instruction")])},WithdrawNonceAccount:{index:5,layout:U([q("instruction"),Ie("lamports")])},InitializeNonceAccount:{index:6,layout:U([q("instruction"),G("authorized")])},AuthorizeNonceAccount:{index:7,layout:U([q("instruction"),G("authorized")])},Allocate:{index:8,layout:U([q("instruction"),Ie("space")])},AllocateWithSeed:{index:9,layout:U([q("instruction"),G("base"),At("seed"),Ie("space"),G("programId")])},AssignWithSeed:{index:10,layout:U([q("instruction"),G("base"),At("seed"),G("programId")])},TransferWithSeed:{index:11,layout:U([q("instruction"),Tt("lamports"),At("seed"),G("programId")])},UpgradeNonceAccount:{index:12,layout:U([q("instruction")])}});new H("11111111111111111111111111111111");new H("BPFLoader2111111111111111111111111111111111");var Yc=Object.prototype.toString,Qc=Object.keys||function(r){var e=[];for(var t in r)e.push(t);return e};function Ft(r,e){var t,n,s,o,i,a,c;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return Ft(r.toJSON(),e);if(c=Yc.call(r),c==="[object Array]"){for(s="[",n=r.length-1,t=0;t<n;t++)s+=Ft(r[t],!0)+",";return n>-1&&(s+=Ft(r[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=Qc(r).sort(),n=o.length,s="",t=0;t<n;)i=o[t],a=Ft(r[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(r);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}var eu=function(r){var e=Ft(r,!1);if(e!==void 0)return""+e},hs=eu;const Nt=32;function er(r){let e=0;for(;r>1;)r/=2,e++;return e}function tu(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class nu{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=er(tu(e+Nt+1))-er(Nt)-1,n=this.getSlotsInEpoch(t),s=e-(n-Nt);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Nt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+er(Nt)):this.slotsPerEpoch}}class ps extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class N extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var ru=globalThis.fetch;class su extends Rc{constructor(e,t,n){const s=o=>{const i=Tc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}const ou=160,iu=64,au=ou/iu,cu=1e3/au;function uu(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const gs=56;class ys{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=uu(lu,e),n=e.length-gs;se(n>=0,"lookup table is invalid"),se(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=U([be(G(),s,"addresses")]).decode(e.slice(gs));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new H(t.authority[0]):void 0,addresses:o.map(i=>new H(i))}}}const lu={index:1,layout:U([q("typeIndex"),Tt("deactivationSlot"),de("lastExtendedSlot"),Y("lastExtendedStartIndex"),Y(),be(G(),gt(Y(),-1),"authority")])},fu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function du(r){const e=r.match(fu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const le=tn(Or(H),E(),r=>new H(r)),Fo=Ur([E(),ie("base64")]),Fr=tn(Or(O),Fo,r=>O.from(r[0],"base64")),hu=30*1e3;function pu(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function oe(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function qo(r){return Ae([_({jsonrpc:ie("2.0"),id:E(),result:r}),_({jsonrpc:ie("2.0"),id:E(),error:_({code:en(),message:E(),data:K($a())})})])}const gu=qo(en());function W(r){return tn(qo(r),gu,e=>"error"in e?e:{...e,result:B(e.result,r)})}function ue(r){return W(_({context:_({slot:g()}),value:r}))}function Hn(r){return _({context:_({slot:g()}),value:r})}function tr(r,e){return r===0?new Wt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new H(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ee.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Ze(e)}const yu=_({foundation:g(),foundationTerm:g(),initial:g(),taper:g(),terminal:g()}),mu=W(T(L(_({epoch:g(),effectiveSlot:g(),amount:g(),postBalance:g(),commission:K(L(g()))})))),wu=T(_({slot:g(),prioritizationFee:g()})),bu=_({total:g(),validator:g(),foundation:g(),epoch:g()}),vu=_({epoch:g(),slotIndex:g(),slotsInEpoch:g(),absoluteSlot:g(),blockHeight:K(g()),transactionCount:K(g())}),xu=_({slotsPerEpoch:g(),leaderScheduleSlotOffset:g(),warmup:Je(),firstNormalEpoch:g(),firstNormalSlot:g()}),Su=po(E(),T(g())),vt=L(Ae([_({}),E()])),_u=_({err:vt}),ku=ie("receivedSignature"),Au=_({"solana-core":E(),"feature-set":K(g())}),ms=ue(_({err:L(Ae([_({}),E()])),logs:L(T(E())),accounts:K(L(T(L(_({executable:Je(),owner:E(),lamports:g(),data:T(E()),rentEpoch:K(g())}))))),unitsConsumed:K(g()),returnData:K(L(_({programId:E(),data:Ur([E(),ie("base64")])})))})),Eu=ue(_({byIdentity:po(E(),T(g())),range:_({firstSlot:g(),lastSlot:g()})}));function Iu(r,e,t,n,s,o){const i=t||ru;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(f,l)=>{const w=await new Promise((d,h)=>{try{n(f,l,(p,y)=>d([p,y]))}catch(p){h(p)}});return await i(...w)}),new bc(async(f,l)=>{const w={method:"POST",body:f,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Il)};try{let d=5,h,p=500;for(;c?h=await c(r,w):h=await i(r,w),!(h.status!==429||s===!0||(d-=1,d===0));)console.log(`Server responded with ${h.status} ${h.statusText}.  Retrying after ${p}ms delay...`),await kt(p),p*=2;const y=await h.text();h.ok?l(null,y):l(new Error(`${h.status} ${h.statusText}: ${y}`))}catch(d){d instanceof Error&&l(d)}},{})}function Bu(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function Ru(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const Tu=W(yu),Lu=W(bu),Pu=W(wu),Cu=W(vu),Ou=W(xu),Uu=W(Su),Nu=W(g()),Mu=ue(_({total:g(),circulating:g(),nonCirculating:g(),nonCirculatingAccounts:T(le)})),lr=_({amount:E(),uiAmount:L(g()),decimals:g(),uiAmountString:K(E())}),Fu=ue(T(_({address:le,amount:E(),uiAmount:L(g()),decimals:g(),uiAmountString:K(E())}))),qu=ue(T(_({pubkey:le,account:_({executable:Je(),owner:le,lamports:g(),data:Fr,rentEpoch:g()})}))),fr=_({program:E(),parsed:en(),space:g()}),Hu=ue(T(_({pubkey:le,account:_({executable:Je(),owner:le,lamports:g(),data:fr,rentEpoch:g()})}))),Ku=ue(T(_({lamports:g(),address:le}))),Gt=_({executable:Je(),owner:le,lamports:g(),data:Fr,rentEpoch:g()}),Du=_({pubkey:le,account:Gt}),zu=tn(Ae([Or(O),fr]),Ae([Fo,fr]),r=>Array.isArray(r)?B(r,Fr):r),dr=_({executable:Je(),owner:le,lamports:g(),data:zu,rentEpoch:g()}),ju=_({pubkey:le,account:dr}),$u=_({state:Ae([ie("active"),ie("inactive"),ie("activating"),ie("deactivating")]),active:g(),inactive:g()}),Wu=W(T(_({signature:E(),slot:g(),err:vt,memo:L(E()),blockTime:K(L(g()))}))),Gu=W(T(_({signature:E(),slot:g(),err:vt,memo:L(E()),blockTime:K(L(g()))}))),Vu=_({subscription:g(),result:Hn(Gt)}),Ju=_({pubkey:le,account:Gt}),Zu=_({subscription:g(),result:Hn(Ju)}),Xu=_({parent:g(),slot:g(),root:g()}),Yu=_({subscription:g(),result:Xu}),Qu=Ae([_({type:Ae([ie("firstShredReceived"),ie("completed"),ie("optimisticConfirmation"),ie("root")]),slot:g(),timestamp:g()}),_({type:ie("createdBank"),parent:g(),slot:g(),timestamp:g()}),_({type:ie("frozen"),slot:g(),timestamp:g(),stats:_({numTransactionEntries:g(),numSuccessfulTransactions:g(),numFailedTransactions:g(),maxTransactionsPerEntry:g()})}),_({type:ie("dead"),slot:g(),timestamp:g(),err:E()})]),el=_({subscription:g(),result:Qu}),tl=_({subscription:g(),result:Hn(Ae([_u,ku]))}),nl=_({subscription:g(),result:g()}),rl=_({pubkey:E(),gossip:L(E()),tpu:L(E()),rpc:L(E()),version:L(E())}),ws=_({votePubkey:E(),nodePubkey:E(),activatedStake:g(),epochVoteAccount:Je(),epochCredits:T(Ur([g(),g(),g()])),commission:g(),lastVote:g(),rootSlot:L(g())}),sl=W(_({current:T(ws),delinquent:T(ws)})),ol=Ae([ie("processed"),ie("confirmed"),ie("finalized")]),il=_({slot:g(),confirmations:L(g()),err:vt,confirmationStatus:K(ol)}),al=ue(T(L(il))),cl=W(g()),Ho=_({accountKey:le,writableIndexes:T(g()),readonlyIndexes:T(g())}),qr=_({signatures:T(E()),message:_({accountKeys:T(E()),header:_({numRequiredSignatures:g(),numReadonlySignedAccounts:g(),numReadonlyUnsignedAccounts:g()}),instructions:T(_({accounts:T(g()),data:E(),programIdIndex:g()})),recentBlockhash:E(),addressTableLookups:K(T(Ho))})}),Ko=_({pubkey:le,signer:Je(),writable:Je(),source:K(Ae([ie("transaction"),ie("lookupTable")]))}),Do=_({accountKeys:T(Ko),signatures:T(E())}),zo=_({parsed:en(),program:E(),programId:le}),jo=_({accounts:T(le),data:E(),programId:le}),ul=Ae([jo,zo]),ll=Ae([_({parsed:en(),program:E(),programId:E()}),_({accounts:T(E()),data:E(),programId:E()})]),$o=tn(ul,ll,r=>"accounts"in r?B(r,jo):B(r,zo)),Wo=_({signatures:T(E()),message:_({accountKeys:T(Ko),instructions:T($o),recentBlockhash:E(),addressTableLookups:K(L(T(Ho)))})}),Bn=_({accountIndex:g(),mint:E(),owner:K(E()),uiTokenAmount:lr}),Go=_({writable:T(le),readonly:T(le)}),Kn=_({err:vt,fee:g(),innerInstructions:K(L(T(_({index:g(),instructions:T(_({accounts:T(g()),data:E(),programIdIndex:g()}))})))),preBalances:T(g()),postBalances:T(g()),logMessages:K(L(T(E()))),preTokenBalances:K(L(T(Bn))),postTokenBalances:K(L(T(Bn))),loadedAddresses:K(Go),computeUnitsConsumed:K(g())}),Hr=_({err:vt,fee:g(),innerInstructions:K(L(T(_({index:g(),instructions:T($o)})))),preBalances:T(g()),postBalances:T(g()),logMessages:K(L(T(E()))),preTokenBalances:K(L(T(Bn))),postTokenBalances:K(L(T(Bn))),loadedAddresses:K(Go),computeUnitsConsumed:K(g())}),Ot=Ae([ie(0),ie("legacy")]),xt=_({pubkey:E(),lamports:g(),postBalance:L(g()),rewardType:L(E()),commission:K(L(g()))}),fl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),transactions:T(_({transaction:qr,meta:L(Kn),version:K(Ot)})),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),dl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),hl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),transactions:T(_({transaction:Do,meta:L(Kn),version:K(Ot)})),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),pl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),transactions:T(_({transaction:Wo,meta:L(Hr),version:K(Ot)})),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),gl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),transactions:T(_({transaction:Do,meta:L(Hr),version:K(Ot)})),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),yl=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),rewards:K(T(xt)),blockTime:L(g()),blockHeight:L(g())}))),ml=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),transactions:T(_({transaction:qr,meta:L(Kn)})),rewards:K(T(xt)),blockTime:L(g())}))),bs=W(L(_({blockhash:E(),previousBlockhash:E(),parentSlot:g(),signatures:T(E()),blockTime:L(g())}))),nr=W(L(_({slot:g(),meta:Kn,blockTime:K(L(g())),transaction:qr,version:K(Ot)}))),on=W(L(_({slot:g(),transaction:Wo,meta:L(Hr),blockTime:K(L(g())),version:K(Ot)}))),wl=ue(_({blockhash:E(),feeCalculator:_({lamportsPerSignature:g()})})),bl=ue(_({blockhash:E(),lastValidBlockHeight:g()})),vl=_({slot:g(),numTransactions:g(),numSlots:g(),samplePeriodSecs:g()}),xl=W(T(vl)),Sl=ue(L(_({feeCalculator:_({lamportsPerSignature:g()})}))),_l=W(E()),kl=W(E()),Al=_({err:vt,logs:T(E()),signature:E()}),El=_({result:Hn(Al),subscription:g()}),Il={"solana-client":"js/0.0.0-development"};class Vo{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async f=>{const{commitment:l,config:w}=oe(f),d=this._buildArgs([],l,void 0,w),h=hs(d);return u[h]=u[h]??(async()=>{try{const p=await this._rpcRequest("getBlockHeight",d),y=B(p,W(g()));if("error"in y)throw new N(y.error,"failed to get block height information");return y.result}finally{delete u[h]}})(),await u[h]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=pu(e),this._rpcWsEndpoint=n||du(e),this._rpcClient=Iu(e,s,o,i,a,c),this._rpcRequest=Bu(this._rpcClient),this._rpcBatchRequest=Ru(this._rpcClient),this._rpcWebSocket=new su(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=B(i,ue(g()));if("error"in a)throw new N(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=B(t,W(L(g())));if("error"in n)throw new N(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=B(e,W(g()));if("error"in t)throw new N(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=B(e,Nu);if("error"in t)throw new N(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=B(n,Mu);if("error"in s)throw new N(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=B(s,ue(lr));if("error"in o)throw new N(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=B(s,ue(lr));if("error"in o)throw new N(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=oe(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=B(c,qu);if("error"in u)throw new N(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=B(i,Hu);if("error"in a)throw new N(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=B(s,Ku);if("error"in o)throw new N(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=B(s,Fu);if("error"in o)throw new N(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=B(i,ue(L(Gt)));if("error"in a)throw new N(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=B(i,ue(L(dr)));if("error"in a)throw new N(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=oe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=B(a,ue(T(L(dr))));if("error"in c)throw new N(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=oe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=B(a,ue(T(L(Gt))));if("error"in c)throw new N(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=oe(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=B(a,W($u));if("error"in c)throw new N(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=oe(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),u=B(c,W(T(Du)));if("error"in u)throw new N(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=B(i,W(T(ju)));if("error"in a)throw new N(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let n;if(typeof e=="string")n=e;else{const o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=ee.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return se(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(l,w)=>{n=void 0;const d={context:w,value:l};c({__type:Ke.PROCESSED,response:d})},e);const f=new Promise(l=>{n==null?l():s=this._onSubscriptionStateChange(n,w=>{w==="subscribed"&&l()})});(async()=>{if(await f,o)return;const l=await this.getSignatureStatus(t);if(o||l==null)return;const{context:w,value:d}=l;if(d!=null)if(d?.err)u(d.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(d.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(d.confirmationStatus==="processed"||d.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Ke.PROCESSED,response:{context:w,value:d}})}})()}catch(f){u(f)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(l=>{const w=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let d=await w();if(!o){for(;d<=n;)if(await kt(1e3),o||(d=await w(),o))return;l({__type:Ke.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let f;try{const l=await Promise.race([u,c,i]);if(l.__type===Ke.PROCESSED)f=l.response;else throw new Oo(s)}finally{o=!0,a()}return f}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(d=>{let h=o,p=null;const y=async()=>{try{const{context:x,value:S}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return p=x.slot,S?.nonce}catch{return h}};(async()=>{if(h=await y(),!a)for(;;){if(o!==h){d({__type:Ke.NONCE_INVALID,slotInWhichNonceDidAdvance:p});return}if(await kt(2e3),a||(h=await y(),a))return}})()}),{abortConfirmation:u,confirmationPromise:f}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),l=this.getCancellationPromise(t);let w;try{const d=await Promise.race([l,f,c]);if(d.__type===Ke.PROCESSED)w=d.response;else{let h;for(;;){const p=await this.getSignatureStatus(i);if(p==null)break;if(p.context.slot<(d.slotInWhichNonceDidAdvance??n)){await kt(400);continue}h=p;break}if(h?.value){const p=e||"finalized",{confirmationStatus:y}=h.value;switch(p){case"processed":case"recent":if(y!=="processed"&&y!=="confirmed"&&y!=="finalized")throw new Mt(i);break;case"confirmed":case"single":case"singleGossip":if(y!=="confirmed"&&y!=="finalized")throw new Mt(i);break;case"finalized":case"max":case"root":if(y!=="finalized")throw new Mt(i);break;default:(x=>{})(p)}w={context:h.context,value:{err:h.value.err}}}else throw new Mt(i)}}finally{a=!0,u()}return w}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Ke.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Ke.PROCESSED)a=c.response;else throw new Uo(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=B(e,W(T(rl)));if("error"in t)throw new N(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=B(n,sl);if("error"in s)throw new N(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=B(o,W(g()));if("error"in i)throw new N(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=B(o,W(E()));if("error"in i)throw new N(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=B(s,W(T(le)));if("error"in o)throw new N(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);se(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=B(s,al);if("error"in o)throw new N(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=B(o,W(g()));if("error"in i)throw new N(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=B(n,Tu);if("error"in s)throw new N(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=oe(n),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=B(a,mu);if("error"in c)throw new N(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=B(e,Lu);if("error"in t)throw new N(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=B(o,Cu);if("error"in i)throw new N(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=B(e,Ou);if("error"in t)throw new N(t.error,"failed to get epoch schedule");const n=t.result;return new nu(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=B(e,Uu);if("error"in t)throw new N(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=B(s,cl);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=B(n,wl);if("error"in s)throw new N(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=B(t,xl);if("error"in n)throw new N(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=B(s,Sl);if("error"in o)throw new N(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=Rt(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=B(o,ue(L(g())));if("error"in i)throw new N(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=this._buildArgs(t?.length?[t]:[]),s=await this._rpcRequest("getRecentPrioritizationFees",n),o=B(s,Pu);if("error"in o)throw new N(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=B(o,bl);if("error"in i)throw new N(i.error,"failed to get latest blockhash");return i.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=B(e,W(Au));if("error"in t)throw new N(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=B(e,W(E()));if("error"in t)throw new N(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=B(i,hl);if("error"in a)throw a.error;return a.result}case"none":{const a=B(i,dl);if("error"in a)throw a.error;return a.result}default:{const a=B(i,fl);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:f,version:l})=>({meta:f,transaction:{...u,message:tr(l,u.message)},version:l}))}:null}}}catch(a){throw new N(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=B(i,gl);if("error"in a)throw a.error;return a.result}case"none":{const a=B(i,yl);if("error"in a)throw a.error;return a.result}default:{const a=B(i,pl);if("error"in a)throw a.error;return a.result}}}catch(a){throw new N(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=B(o,Eu);if("error"in i)throw new N(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=B(i,nr);if("error"in a)throw new N(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:tr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=oe(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=B(i,on);if("error"in a)throw new N(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=oe(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=B(c,on);if("error"in u)throw new N(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:s}=oe(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=B(c,nr);if("error"in u)throw new N(u.error,"failed to get transactions");const f=u.result;return f&&{...f,transaction:{...f.transaction,message:tr(f.version,f.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=B(s,ml);if("error"in o)throw new N(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const f=new Ze(c.message);return{meta:u,transaction:{...c,message:f}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:ot.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=B(o,W(T(g())));if("error"in i)throw new N(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=B(s,bs);if("error"in o)throw new N(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=B(s,bs);if("error"in o)throw new N(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=B(s,nr);if("error"in o)throw new N(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new Ze(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:ot.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=B(s,on);if("error"in o)throw new N(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=B(i,on);if("error"in a)throw new N(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=B(o,Wu);if("error"in i)throw new N(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=B(o,Gu);if("error"in i)throw new N(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new ys({key:e,state:ys.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=Mr.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=B(n,_l);if("error"in s)throw new N(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await kt(100);const n=Date.now()-this._blockhashInfo.lastFetch>=hu;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await kt(cu/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=oe(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=B(o,ue(g()));if("error"in i)throw new N(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const p=e.serialize(),y=O.from(p).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const x=t||{};x.encoding="base64","commitment"in x||(x.commitment=this.commitment);const S=[y,x],b=await this._rpcRequest("simulateTransaction",S),C=B(b,ms);if("error"in C)throw new Error("failed to simulate transaction: "+C.error.message);return C.result}let s;if(e instanceof ot){let h=e;s=new ot,s.feePayer=h.feePayer,s.instructions=e.instructions,s.nonceInfo=h.nonceInfo,s.signatures=h.signatures}else s=ot.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let h=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(h);if(s.lastValidBlockHeight=p.lastValidBlockHeight,s.recentBlockhash=p.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const y=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(y)&&!this._blockhashInfo.transactionSignatures.includes(y)){this._blockhashInfo.simulatedSignatures.push(y);break}else h=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),f={encoding:"base64",commitment:this.commitment};if(n){const h=(Array.isArray(n)?n:i.nonProgramIds()).map(p=>p.toBase58());f.accounts={encoding:"base64",addresses:h}}o&&(f.sigVerify=!0);const l=[u,f],w=await this._rpcRequest("simulateTransaction",l),d=B(w,ms);if("error"in d){let h;if("data"in d.error&&(h=d.error.data.logs,h&&Array.isArray(h))){const p=`
    `,y=p+h.join(p);console.error(d.error.message,y)}throw new ps("failed to simulate transaction: "+d.error.message,h)}return d.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=Rt(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=B(a,kl);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new ps("failed to send transaction: "+c.error.message,u)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){const n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var n;const s=this._subscriptionHashByClientSubscriptionId[e];if(s==null)return()=>{};const o=(n=this._subscriptionStateChangeCallbacksByHash)[s]||(n[s]=new Set);return o.add(t),()=>{o.delete(t),o.size===0&&delete this._subscriptionStateChangeCallbacksByHash[s]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=B(e,Vu);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=hs([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];se(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=B(e,Zu);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const o=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=B(e,El);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=B(e,Yu);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=B(e,el);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=B(e,tl);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=B(e,nl);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Kt{constructor(e){this._keypair=void 0,this._keypair=e??us()}static generate(){return new Kt(us())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=ur(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Kt({publicKey:n,secretKey:e})}static fromSeed(e){const t=ur(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Kt({publicKey:t,secretKey:n})}get publicKey(){return new H(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:U([q("instruction"),Tt("recentSlot"),Y("bumpSeed")])},FreezeLookupTable:{index:1,layout:U([q("instruction")])},ExtendLookupTable:{index:2,layout:U([q("instruction"),Tt(),be(G(),gt(q(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:U([q("instruction")])},CloseLookupTable:{index:4,layout:U([q("instruction")])}});new H("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:U([Y("instruction"),q("units"),q("additionalFee")])},RequestHeapFrame:{index:1,layout:U([Y("instruction"),q("bytes")])},SetComputeUnitLimit:{index:2,layout:U([Y("instruction"),q("units")])},SetComputeUnitPrice:{index:3,layout:U([Y("instruction"),Tt("microLamports")])}});new H("ComputeBudget111111111111111111111111111111");U([Y("numSignatures"),Y("padding"),Ce("signatureOffset"),Ce("signatureInstructionIndex"),Ce("publicKeyOffset"),Ce("publicKeyInstructionIndex"),Ce("messageDataOffset"),Ce("messageDataSize"),Ce("messageInstructionIndex")]);new H("Ed25519SigVerify111111111111111111111111111");Ls.hmacSha256Sync=(r,...e)=>{const t=Lo.create(ar,r);return e.forEach(n=>t.update(n)),t.digest()};Ls.isValidPrivateKey;U([Y("numSignatures"),Ce("signatureOffset"),Y("signatureInstructionIndex"),Ce("ethAddressOffset"),Y("ethAddressInstructionIndex"),Ce("messageDataOffset"),Ce("messageDataSize"),Y("messageInstructionIndex"),ne(20,"ethAddress"),ne(64,"signature"),Y("recoveryId")]);new H("KeccakSecp256k11111111111111111111111111111");new H("StakeConfig11111111111111111111111111111111");class vs{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}vs.default=new vs(0,0,H.default);Object.freeze({Initialize:{index:0,layout:U([q("instruction"),jc(),$c()])},Authorize:{index:1,layout:U([q("instruction"),G("newAuthorized"),q("stakeAuthorizationType")])},Delegate:{index:2,layout:U([q("instruction")])},Split:{index:3,layout:U([q("instruction"),Ie("lamports")])},Withdraw:{index:4,layout:U([q("instruction"),Ie("lamports")])},Deactivate:{index:5,layout:U([q("instruction")])},Merge:{index:7,layout:U([q("instruction")])},AuthorizeWithSeed:{index:8,layout:U([q("instruction"),G("newAuthorized"),q("stakeAuthorizationType"),At("authoritySeed"),G("authorityOwner")])}});new H("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:U([q("instruction"),Wc()])},Authorize:{index:1,layout:U([q("instruction"),G("newAuthorized"),q("voteAuthorizationType")])},Withdraw:{index:3,layout:U([q("instruction"),Ie("lamports")])},AuthorizeWithSeed:{index:10,layout:U([q("instruction"),Gc()])}});new H("Vote111111111111111111111111111111111111111");new H("Va1idator1nfo111111111111111111111111111111");_({name:E(),website:K(E()),details:K(E()),keybaseUsername:K(E())});new H("Vote111111111111111111111111111111111111111");U([G("nodePubkey"),G("authorizedWithdrawer"),Y("commission"),de(),be(U([de("slot"),q("confirmationCount")]),gt(q(),-8),"votes"),Y("rootSlotValid"),de("rootSlot"),de(),be(U([de("epoch"),G("authorizedVoter")]),gt(q(),-8),"authorizedVoters"),U([be(U([G("authorizedPubkey"),de("epochOfLastAuthorizedSwitch"),de("targetEpoch")]),32,"buf"),de("idx"),Y("isEmpty")],"priorVoters"),de(),be(U([de("epoch"),de("credits"),de("prevCredits")]),gt(q(),-8),"epochCredits"),U([de("slot"),de("timestamp")],"lastTimestamp")]);function Bl(r){return(e,t,n,s)=>e.method==="solana_chainId"?(t.result=r,s()):n()}function Rl(r){return(e,t,n,s)=>e.method==="solana_provider_config"?(t.result=r,s()):n()}function Jo(r){const{chainId:e}=r;return Vt([Bl(e),Rl(r)])}function Tl(r){const{rpcTarget:e}=r,t=ni({rpcTarget:e});return{networkMiddleware:Vt([Jo(r),t]),fetchMiddleware:t}}function Ll(r){let{getAccounts:e}=r;return Rn(async(t,n,s)=>{const{method:o}=t;if(o!=="getAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.getAccounts not provided");const i=await e(t);n.result=i})}function Pl(r){let{requestAccounts:e}=r;return Rn(async(t,n,s)=>{const{method:o}=t;if(o!=="requestAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.requestAccounts not provided");const i=await e(t);n.result=i})}function De(r,e){return Rn(async(t,n,s)=>{const{method:o}=t;if(o!==r)return s();if(!e)throw new Error(`WalletMiddleware - ${r} not provided`);const i=await e(t);n.result=i})}function Kr(r){const{getAccounts:e,requestAccounts:t,signTransaction:n,signAndSendTransaction:s,signAllTransactions:o,signMessage:i,getPrivateKey:a,getSecretKey:c}=r;return Vt([Pl({requestAccounts:t}),Ll({getAccounts:e}),De("signTransaction",n),De("signAndSendTransaction",s),De("signAllTransactions",o),De("signMessage",i),De("solanaPrivateKey",a),De("private_key",a),De("solanaSecretKey",c)])}function Cl(r){let{addNewChainConfig:e,switchSolanaChain:t}=r;return Vt([De("addSolanaChain",e),De("switchSolanaChain",t)])}function Ol(r){let{updatePrivatekey:e}=r;return Vt([De("updateAccount",e)])}function xs(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function Ss(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?xs(Object(t),!0).forEach(function(n){Lt(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):xs(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class Dr extends gr{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:Ss(Ss({},t.chainConfig),{},{chainNamespace:un.SOLANA})},state:n})}async switchChain(e){return Promise.resolve()}async setupProvider(e){const t=new mr,n=this.getProviderHandlers(e),s=Kr(n);t.push(s);const o=Jo(this.config.chainConfig);t.push(o);const i=this.getInjectedProviderProxy(e);i&&t.push(i);const a=wr(t);this.updateProviderEngineProxy(a),await this.lookupNetwork()}async lookupNetwork(){const{chainConfig:e}=this.config;return this.update({chainId:e.chainId}),e.chainId||""}getInjectedProviderProxy(e){}}const Zo=r=>({requestAccounts:async()=>r.publicKey?[ee.encode(r.publicKey.toBytes())]:[],getAccounts:async()=>r.publicKey?[ee.encode(r.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},signTransaction:async t=>await r.signTransaction(t.params.message),signMessage:async t=>(await r.signMessage(t.params.message,t.params.display)).signature,signAllTransactions:async t=>{var n,s;if(!((n=t.params)!==null&&n!==void 0&&n.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw V.ethErrors.rpc.invalidParams("message");return await r.signAllTransactions(t.params.message)},signAndSendTransaction:async t=>({signature:(await r.signAndSendTransaction(t.params.message)).signature})});function _s(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function Ul(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?_s(Object(t),!0).forEach(function(n){Lt(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):_s(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}function Xo(r){return Rn(async(e,t,n)=>{const s=await r.request(Ul({},e));t.result=s})}class Nl extends Dr{getProviderHandlers(e){return Zo(e)}getInjectedProviderProxy(e){return Xo(e)}}const rr=r=>r.version!==void 0||r instanceof It,Ml=(r,e)=>({requestAccounts:async()=>{const{data:n}=await r.connect();return[n.publicKey]},getAccounts:async()=>{const{data:n}=await r.connect();return[n.publicKey]},getPrivateKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},signTransaction:async n=>{const s=n.params.message;if(!s)throw V.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const o=rr(s)?s.message.serialize():s.serializeMessage(),{data:i}=await r.signTransaction(ee.encode(o));if(!i.publicKey||!i.signature)throw new Error("Invalid signature from slope wallet");const a=new H(i.publicKey),c=ee.decode(i.signature);return s.addSignature(a,O.from(c)),s},signMessage:async n=>{const s=await r.signMessage(n.params.message);return ee.decode(s.data.signature)},signAndSendTransaction:async n=>{const s=e();if(!s)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=n.params.message;if(!o)throw V.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const i=rr(o)?o.message.serialize():o.serializeMessage(),{data:a}=await r.signTransaction(ee.encode(i));if(!a.publicKey||!a.signature)throw new Error("Invalid signature from slope wallet");const c=new H(a.publicKey),u=ee.decode(a.signature);o.addSignature(c,O.from(u));const f=await s.request({method:"solana_provider_config",params:[]});return{signature:await new Vo(f.rpcTarget).sendRawTransaction(o.serialize())}},signAllTransactions:async n=>{var s,o,i;if(!((s=n.params)!==null&&s!==void 0&&s.message)||!((o=n.params)!==null&&o!==void 0&&o.message.length))throw V.ethErrors.rpc.invalidParams("message");const a=n.params.message,{length:c}=a,u=[];for(let d=0;d<c;d++){const h=a[d],p=rr(h)?h.message.serialize():h.serializeMessage();u.push(ee.encode(p))}const{msg:f,data:l}=await r.signAllTransactions(u);if(!l.publicKey||((i=l.signatures)===null||i===void 0?void 0:i.length)!==c)throw new Error(f);const w=new H(l.publicKey);for(let d=0;d<c;d++){const h=ee.decode(l.signatures[d]);a[d].addSignature(w,O.from(h))}return a}});class Fl extends Dr{getProviderHandlers(e){return Ml(e,this.getProviderEngineProxy.bind(this))}}const ql=(r,e)=>{const t=Zo(r);return t.signAndSendTransaction=async n=>{const s=e();if(!s)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=await r.signTransaction(n.params.message),i=await s.request({method:"solana_provider_config",params:[]});return{signature:await new Vo(i.rpcTarget).sendRawTransaction(o.serialize())}},t};class Hl extends Dr{getProviderHandlers(e){return ql(e,this.getProviderEngineProxy.bind(this))}}const Kl=r=>({requestAccounts:async()=>await r.request({method:"solana_requestAccounts",params:{}}),getAccounts:async()=>await r.request({method:"solana_requestAccounts",params:{}}),getPrivateKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw V.ethErrors.rpc.methodNotSupported()},signMessage:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw V.ethErrors.rpc.invalidParams("message");return await r.signMessage(t.params.message)},signTransaction:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw V.ethErrors.rpc.invalidParams("message");const s=t.params.message;return await r.signTransaction(s)},signAndSendTransaction:async t=>{var n;if(!((n=t.params)!==null&&n!==void 0&&n.message))throw V.ethErrors.rpc.invalidParams("message");const s=t.params.message;return{signature:await r.sendTransaction(s)}},signAllTransactions:async t=>{var n,s;if(!((n=t.params)!==null&&n!==void 0&&n.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw V.ethErrors.rpc.invalidParams("message");const o=t.params.message;return await r.signAllTransactions(o)}});function ks(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function an(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?ks(Object(t),!0).forEach(function(n){Lt(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):ks(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class Dl extends gr{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:an(an({},t.chainConfig),{},{chainNamespace:un.SOLANA})},state:n})}async switchChain(e){return Promise.resolve()}async setupProvider(e){this.handleInjectedProviderUpdate(e),await this.setupEngine(e)}async lookupNetwork(){if(!this.provider)throw V.ethErrors.provider.custom({message:"Torus solana provider is not initialized",code:4902});const{chainId:e}=this.config.chainConfig,t=await this.provider.request({method:"solana_chainId"}),n=jr(t.toString())?t:`0x${parseInt(t,10).toString(16)}`;if(e!==n)throw yr.rpcConnectionError(`Invalid network, net_version is: ${n}, expected: ${e}`);return this.update({chainId:n}),this.provider.emit("connect",{chainId:this.state.chainId}),this.provider.emit("chainChanged",this.state.chainId),this.state.chainId}async setupEngine(e){const t=Kl(e),n=Kr(t),s=Xo(e),o=new mr;o.push(n),o.push(s);const i=wr(o);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async handleInjectedProviderUpdate(e){e.on("accountsChanged",async t=>{this.provider.emit("accountsChanged",t)}),e.on("chainChanged",async t=>{const n=jr(t)?t:`0x${parseInt(t,10).toString(16)}`;this.configure({chainConfig:an(an({},this.config.chainConfig),{},{chainId:n})}),await this.setupProvider(e)})}}async function zl(r){let{privKey:e,getProviderEngineProxy:t}=r;const n=()=>Kt.fromSecretKey(O.from(e,"hex"));if(typeof e!="string")throw yr.invalidParams("privKey must be a string");const s=n();return{requestAccounts:async()=>[s.publicKey.toBase58()],getAccounts:async()=>[s.publicKey.toBase58()],getPrivateKey:async()=>e,getSecretKey:async()=>ee.encode(s.secretKey),signTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw V.ethErrors.rpc.invalidParams("message");const c=i.params.message;return c.version!==void 0||c instanceof It?c.sign([s]):c.partialSign(s),c},signMessage:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw V.ethErrors.rpc.invalidParams("message");return ri.sign.detached(i.params.message,s.secretKey)},signAndSendTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw V.ethErrors.rpc.invalidParams("message");const c=t();if(!c)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const u=i.params.message;return u.version!==void 0||u instanceof It?u.sign([s]):u.partialSign(s),{signature:await c.request({method:"sendTransaction",params:[O.from(u.serialize()).toString("base64"),{encoding:"base64"}]})}},signAllTransactions:async i=>{var a,c,u;if(!((a=i.params)!==null&&a!==void 0&&a.message)||!((c=i.params)!==null&&c!==void 0&&c.message.length))throw V.ethErrors.rpc.invalidParams("message");const f=(u=i.params)===null||u===void 0?void 0:u.message;for(const l of f||[]){const w=l;w.version!==void 0||w instanceof It?w.sign([s]):w.partialSign(s)}return f}}}function As(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter(function(s){return Object.getOwnPropertyDescriptor(r,s).enumerable})),t.push.apply(t,n)}return t}function Es(r){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?As(Object(t),!0).forEach(function(n){Lt(r,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):As(Object(t)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(t,n))})}return r}class hr extends gr{constructor(e){let{config:t,state:n}=e;super({config:{chainConfig:Es(Es({},t.chainConfig),{},{chainNamespace:un.SOLANA})},state:n})}async enable(){if(!this.state.privateKey)throw V.ethErrors.provider.custom({message:"Private key is not found in state, plz pass it in constructor state param",code:4902});return await this.setupProvider(this.state.privateKey),this._providerEngineProxy.request({method:"eth_accounts"})}async setupProvider(e){const t=await zl({privKey:e,getProviderEngineProxy:this.getProviderEngineProxy.bind(this)}),n=Kr(t),s=new mr,{networkMiddleware:o}=Tl(this.config.chainConfig);s.push(this.getChainSwitchMiddleware()),s.push(this.getAccountMiddleware()),s.push(n),s.push(o);const i=wr(s);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async updateAccount(e){if(!this._providerEngineProxy)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});await this._providerEngineProxy.request({method:"solanaPrivateKey"})!==e.privateKey&&(await this.setupProvider(e.privateKey),this._providerEngineProxy.emit("accountsChanged",{accounts:await this._providerEngineProxy.request({method:"requestAccounts"})}))}async switchChain(e){if(!this._providerEngineProxy)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const t=this.getChainConfig(e.chainId);this.update({chainId:"loading"}),this.configure({chainConfig:t});const n=await this._providerEngineProxy.request({method:"solanaPrivateKey"});await this.setupProvider(n)}async lookupNetwork(){if(!this._providerEngineProxy)throw V.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const e=await this._providerEngineProxy.request({method:"getHealth",params:[]}),{chainConfig:t}=this.config;if(e!=="ok")throw yr.rpcConnectionError(`Failed to lookup network for following rpc target: ${t.rpcTarget}`);return this.update({chainId:t.chainId}),this.state.chainId!==t.chainId&&(this.provider.emit("chainChanged",this.state.chainId),this.provider.emit("connect",{chainId:this.state.chainId})),this.state.chainId}getChainSwitchMiddleware(){return Cl({addNewChainConfig:async n=>{if(!n.params)throw V.ethErrors.rpc.invalidParams("Missing request params");const{chainId:s,chainName:o,rpcUrls:i,blockExplorerUrls:a,nativeCurrency:c}=n.params;if(!s)throw V.ethErrors.rpc.invalidParams("Missing chainId in chainParams");if(!i||i.length===0)throw V.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");if(!c)throw V.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");this.addChain({chainNamespace:un.SOLANA,chainId:s,ticker:c?.symbol||"SOL",tickerName:c?.name||"Solana",displayName:o,rpcTarget:i[0],blockExplorer:a?.[0]||"",decimals:c?.decimals||9})},switchSolanaChain:async n=>{if(!n.params)throw V.ethErrors.rpc.invalidParams("Missing request params");if(!n.params.chainId)throw V.ethErrors.rpc.invalidParams("Missing chainId");await this.switchChain(n.params)}})}getAccountMiddleware(){return Ol({updatePrivatekey:async t=>{if(!t.params)throw V.ethErrors.rpc.invalidParams("Missing request params");if(!t.params.privateKey)throw V.ethErrors.rpc.invalidParams("Missing privateKey");const{privateKey:n}=t.params;await this.updateAccount({privateKey:n})}})}}Lt(hr,"getProviderInstance",async r=>{const e=new hr({config:{chainConfig:r.chainConfig}});return await e.setupProvider(r.privKey),e});class jl{constructor(e){Lt(this,"provider",void 0),this.provider=e}async requestAccounts(){return await this.provider.request({method:"requestAccounts",params:{}})}async signAndSendTransaction(e){const{signature:t}=await this.provider.request({method:"signAndSendTransaction",params:{message:e}});return{signature:t}}async signTransaction(e){return await this.provider.request({method:"signTransaction",params:{message:e}})}async signAllTransactions(e){return await this.provider.request({method:"signAllTransactions",params:{message:e}})}async signMessage(e){return await this.provider.request({method:"signMessage",params:{message:e}})}async request(e){return await this.provider.request(e)}}const Jl=Object.freeze(Object.defineProperty({__proto__:null,PhantomInjectedProvider:Nl,SlopeInjectedProxyProvider:Fl,SolanaPrivateKeyProvider:hr,SolanaWallet:jl,SolflareInjectedProvider:Hl,TorusInjectedProvider:Dl},Symbol.toStringTag,{value:"Module"}));export{H as P,Dl as T,Nl as a,ee as b,Jl as s};
