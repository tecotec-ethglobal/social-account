import{_ as o,W as u,A as v,C as A,u as f,v as i,x as l,y as w,w as p,z as _,D as c}from"./index-dcd969e5.js";import{B as N}from"./baseSolanaAdapter.esm-678240f6.js";import{a as P}from"./solanaProvider.esm-a1eeb0c3.js";import"./nacl-fast-b80eb36f.js";function E(r,t,n){return new Promise((e,a)=>{n>0?setTimeout(async()=>{const h=await r();h&&e(h),h||E(r,t,n-1).then(s=>(e(s),s)).catch(s=>a(s))},t):e(!1)})}const C=async function(){var r;let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{interval:1e3,count:3};return typeof window<"u"&&!!((r=window.solana)!==null&&r!==void 0&&r.isPhantom)||await E(()=>{var a;return(a=window.solana)===null||a===void 0?void 0:a.isPhantom},t.interval,t.count)?window.solana:null};class y extends N{constructor(){super(...arguments),o(this,"name",u.PHANTOM),o(this,"adapterNamespace",v.SOLANA),o(this,"currentChainNamespace",A.SOLANA),o(this,"type",f.EXTERNAL),o(this,"status",i.NOT_READY),o(this,"_wallet",null),o(this,"phantomProvider",null),o(this,"_onDisconnect",()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===i.CONNECTED?i.READY:i.NOT_READY,this.emit(l.DISCONNECTED))})}get isWalletConnected(){var t;return!!((t=this._wallet)!==null&&t!==void 0&&t.isConnected&&this.status===i.CONNECTED)}get provider(){var t;return((t=this.phantomProvider)===null||t===void 0?void 0:t.provider)||null}set provider(t){throw new Error("Not implemented")}async init(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await C({interval:500,count:3}),!this._wallet)throw w.notInstalled();this.phantomProvider=new P({config:{chainConfig:this.chainConfig}}),this.status=i.READY,this.emit(l.READY,u.PHANTOM);try{p.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(n){p.error("Failed to connect with cached phantom provider",n),this.emit("ERRORED",n)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=i.CONNECTING,this.emit(l.CONNECTING,{adapter:u.PHANTOM}),!this._wallet)throw w.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{const n=this._wallet._handleDisconnect;try{await new Promise((e,a)=>{const h=async()=>{await this.connectWithProvider(this._wallet),e(this.provider)};if(!this._wallet){a(w.notInstalled());return}this._wallet.once("connect",h),this._wallet._handleDisconnect=function(){a(w.windowClosed());for(var s=arguments.length,m=new Array(s),d=0;d<s;d++)m[d]=arguments[d];return n.apply(t._wallet,m)},this._wallet.connect().catch(s=>{a(s)})})}catch(e){throw e instanceof _?e:c.connectionError(e?.message)}finally{this._wallet._handleDisconnect=n}}if(!this._wallet.publicKey)throw c.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(n){throw this.status=i.READY,this.rehydrated=!1,this.emit(l.ERRORED,n),n}}async disconnect(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var n;await((n=this._wallet)===null||n===void 0?void 0:n.disconnect()),t.cleanup&&(this.status=i.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(e){this.emit(l.ERRORED,c.disconnectionError(e?.message))}}async getUserInfo(){if(!this.isWalletConnected)throw c.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async connectWithProvider(t){if(!this.phantomProvider)throw c.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=i.CONNECTED,this.emit(l.CONNECTED,{adapter:u.PHANTOM,reconnected:this.rehydrated}),this.provider}}export{y as PhantomAdapter};
