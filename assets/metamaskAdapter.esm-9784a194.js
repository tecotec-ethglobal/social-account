import{_ as i,A as u,C as E,u as p,W as h,v as r,y as w,x as a,w as A,D as s}from"./index-33dc9532.js";import{B as v}from"./baseEvmAdapter.esm-829c1c27.js";function N({mustBeMetaMask:n=!1,silent:e=!1,timeout:t=3e3}={}){l();let c=!1;return new Promise(m=>{window.ethereum?o():(window.addEventListener("ethereum#initialized",o,{once:!0}),setTimeout(()=>{o()},t));function o(){if(c)return;c=!0,window.removeEventListener("ethereum#initialized",o);const{ethereum:d}=window;d&&(!n||d.isMetaMask)?m(d):(!e&&console.error("@metamask/detect-provider:",n&&d?"Non-MetaMask window.ethereum detected.":"Unable to detect window.ethereum."),m(null))}});function l(){if(typeof n!="boolean")throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");if(typeof e!="boolean")throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");if(typeof t!="number")throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.")}}var f=N;class C extends v{constructor(){super(...arguments),i(this,"adapterNamespace",u.EIP155),i(this,"currentChainNamespace",E.EIP155),i(this,"type",p.EXTERNAL),i(this,"name",h.METAMASK),i(this,"status",r.NOT_READY),i(this,"metamaskProvider",null)}get provider(){return this.status===r.CONNECTED&&this.metamaskProvider?this.metamaskProvider:null}set provider(e){throw new Error("Not implemented")}async init(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(await super.init(e),super.checkInitializationRequirements(),this.metamaskProvider=await f({mustBeMetaMask:!0}),!this.metamaskProvider)throw w.notInstalled("Metamask extension is not installed");this.status=r.READY,this.emit(a.READY,h.METAMASK);try{A.debug("initializing metamask adapter"),e.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(t){this.emit(a.ERRORED,t)}}async connect(){if(super.checkConnectionRequirements(),!this.metamaskProvider)throw s.notConnectedError("Not able to connect with metamask");this.status=r.CONNECTING,this.emit(a.CONNECTING,{adapter:h.METAMASK});try{await this.metamaskProvider.request({method:"eth_requestAccounts"});const{chainId:e}=this.metamaskProvider;if(e!==this.chainConfig.chainId&&await this.switchChain(this.chainConfig),this.status=r.CONNECTED,!this.provider)throw s.notConnectedError("Failed to connect with provider");return this.provider.once("disconnect",()=>{this.disconnect()}),this.emit(a.CONNECTED,{adapter:h.METAMASK,reconnected:this.rehydrated}),this.provider}catch(e){throw this.status=r.READY,this.rehydrated=!1,this.emit(a.ERRORED,e),s.connectionError("Failed to login with metamask wallet")}}async disconnect(){var e;let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};await super.disconnectSession(),(e=this.provider)===null||e===void 0||e.removeAllListeners(),t.cleanup?(this.status=r.NOT_READY,this.metamaskProvider=null):this.status=r.READY,await super.disconnect()}async getUserInfo(){if(this.status!==r.CONNECTED)throw s.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(e){if(!this.metamaskProvider)throw s.notConnectedError("Not connected with wallet");try{await this.metamaskProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}catch(t){if(t.code===4902)await this.metamaskProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorer],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18}}]});else throw t}}}export{C as MetamaskAdapter};
